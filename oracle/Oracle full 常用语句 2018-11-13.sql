
-- oracle总结

-- 1.连接数据库

-- 使用sqlplus连接远程计算机数据库
-- a:
-- 简易连接，不用进行网络配置，其实就是tnsname.ora文件,但只支持oracle10g以上
-- sqlplus 用户名/密码@ip地址[:端口]/service_name [as sysdba]
sqlplus ching/123456@10.206.130.108:1521/orcl as sysdba 

-- b:
-- 进行网络配置 oracle9i和以前的版本
-- 图形化操作:net configuration assistant--> 本地net服务名配置-->添加->服务名->协议(选tcp)->主机名称->端口->完成。
-- 文本化操作：编辑$oracle_home/network/admin/tnsnames.ora文件
orcl =
  (description =
    (address_list =
      (address = (protocol = tcp)(host = 10.206.130.108)(port = 1521))
      (address = (protocol = tcp)(host = 10.206.130.108)(port = 1522))
    )
    (connect_data =
      (service_name = orcl)
    )
  )

/*
protocol：客户端与服务器端通讯的协议，一般为tcp，该内容一般不用改

host：数据库侦听所在的机器的机器名或ip地址，数据库侦听一般与数据库在同一个机器上，
所以当我说数据库侦听所在的机器一般也是指数据库所在的机器。在unix或windows下，
可以通过在数据库侦听所在的机器的命令提示符下使hostname命令得到机器名，
或通过ipconfig(for windows) or ifconfig（for unix）命令得到ip地址。
需要注意的是，不管用机器名或ip地址，在客户端一定要用ping命令ping通数据库侦听所在的机器的机器名，
否则需要在hosts文件中加入数据库侦听所在的机器的机器名的解析。 

port：数据库侦听正在侦听的端口.可以察看服务器端的listener.ora文件或在数据库侦听所在的机器的命令提示符下
通过lnsrctl status [listener name]命令察看。此处port的值一定要与数据库侦听正在侦听的端口一样

service_name：在服务器端，用system用户登陆后，sqlplus> show parameter service_name命令察看

如何保证客户端机器连接到oracle数据库呢？
1、首先去oracle的官方网站上http:--www.oracle.com/technology/software/tech/oci/instantclient/index.html下载（下面是10g的）：
　　instantclient-basic-win32-10.2.0.4.zip
　　instantclient-odbc-win32-10.2.0.4.zip
　　instantclient-sqlplus-win32-10.2.0.4.zip
　　将下载的安装包全部解压，放在同一个目录下，比如在d:\sqlplus。

2、 "控制面板"-"系统"-"高级"-"环境变量"-"系统变量"添加几个环境变量：
　　nls_lang = simplified chinese_china.zhs16gbk(或american_america.zhs16gbk)
　　tns_admin = d:\sqlplus
　　ld_library_path = d:\sqlplus
　　sqlpath = d:\sqlplus
　　path变量结尾添加d:\sqlplus

3、在d:\sqlplus目录下创建tnsname.ora文件，自己敲容易出问题，建议直接到安装oracle数据库的机器上拷贝过来用，内容如下：
　　# tnsnames.ora network configuration file: d:\oracle\product\10.1.0\db_2\network\admin\tnsnames.ora
　　# generated by oracle configuration tools.
　　orcl =
　　(description =
　　(address = (protocol = tcp)(host = 192.168.208.120)(port = 1521))
　　(connect_data =
　　(server = dedicated)
　　(service_name = orcl)
　　)
　　)
　　extproc_connection_data =
　　(description =
　　(address_list =
　　(address = (protocol = ipc)(key = extproc))
　　)
　　(connect_data =
　　(sid = plsextproc)
　　(presentation = ro)
　　)
　　)
　　以上文件中，orcl是个连接标示符，可以自己修改，host是远程oracle服务器的地址，port是oracle的服务端口，没有修改过的话，
默认是1521。service_name是远程实例名称。

　　4、命令行下，切换到d:\sqlplus，运行odbc_install.exe，安装odbc驱动。

　　5、使用sql-plus连接
　　命令行下执行sqlplus /nolog
　　进入sqlplus提示符，输入
　　connect <username>/<password>@<连接标识符>
　　或者
　　sqlplus 用户名/密码@192.168.208.120:1521/orcl
　　没有意外的话连接成功。
　　如果上述方法试验没有成功，用下面的方式最直接了
　　sqlplus system/manager@'(description=(address_list=(address=(proto=tcp)(host=192.168.208.120)
  (port=1521)))(connect_data=(service_name=orcl)))'


a．客户端
1．在客户端机器上安装oracle的oracle net通讯软件，它包含在oracle的客户端软件中。 
2．正确配置了sqlnet.ora文件
3．正确配置了tnsname.ora文件

b．服务器端
1．保证listener已经启动 lsntctl start
2．保证数据库已经启动。 sql>startup

*/


-- 使用sqlplus连接本机计算机数据库
sqlplus /nolog

connect "sys"/"&&syspassword" as sysdba
connect sys/&&syspassword as sysdba

conn ching/123456;


-- sqlplus || cmd 执行sql文件 脚本文件
sql> @ abc.sql
sql> start abc.sql


-- 启动数据库
-- a.创建并启动与数据库对应的实例     启动实例
-- b.为实例加载数据库             加载数据库
-- c.将数据库设置为打开状态        打开数据库

-- oracle启动过程涉及几种模式，这些模式涉及不同的文件，每个状态下数据库做不同的事情，
-- 同时这些模式适用于不同的维护需求，主要的模式有三种：nomount、mount、open。

-- nomount：启动数据库实例， 此时读取参数文件，但是不加载数据库；
-- mount：启动数据库实例，加载数据库，但是数据库处于关闭状态；
-- open：启动数据库实例，加载并打开数据库；
-- force：终止实例并重启数据库，这种模式在数据库关闭或者启动遇到问题时使用，这种方式不到万不得已时不要使用，会有数据丢失；
shutdown->nomount->mount->open
startup [nomount|mount|open|force|] [restrict] [pfile=filename]

-- 启动实例
-- startup
startup nomount
-- 加载数据库
alter database mount
-- 打开数据库
alter database open

-- 停止数据库,关闭数据库
-- 需要使用一个有sysdba权限的用户账户连接到oracle，然后使用shutdown语句执行关闭操作
shutdown [normal|transactional|immediate|abort]
-- 关闭也分为3个步骤
-- 关闭数据库
-- 实例卸载数据库
-- 最后终止实例
shutdown immediate;

-- shutdown有四个参数：normal、transactional、immediate、abort。缺省不带任何参数时表示是normal。

-- shutdown normal：   不允许新的连接、等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复，
-- 这种方法往往不能关闭数据库或等待很长时间。

-- shutdown transactional：  不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。

-- shutdown immediate：  不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。
-- 没有结束的事务是自动rollback的。启动时不需要实例恢复。最常用的方法。

-- shutdown abort：  不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。
-- 启动时自动进行实例恢复。一般不推荐采用，只有在数据库无法关闭时使用，可能造成数据库的不一致。


-- 数据库的静默状态和挂起状态

-- 创建初始化参数文件
create pfile 'pfile_name' from spfile 'spfile_name'

-- 显示和设置初始化参数问价
show parameter

-- 启动监听
lsnrctl start

-- 停止监听
lsnrctl stop

-- 查看监听状态
lsnrctl status


-- 2.创建用户
create user ching identified by "123456";

-- 删除用户
drop user ching cascade;

-- 显示当前连接的用户
show user;

-- 查询用户状态为open,locked,expired的用户名
select username from dba_users 
where account_status in ('open', 'locked', 'expired') 
and username not in ('sys','system') 

-- 修改用户密码 修改密码
alter user scott identified by tiger; 

--修改用户密码
alter user ching identified by "123456";

-- 修改登录密码不区分大小写
-- 不区分大小写 为TRUE则是区分大小写
alter SYSTEM SET SEC_CASE_SENSITIVE_LOGON = FALSE;

-- 解锁用户
alter user ching account unlock;

-- 锁定用户,密码过期
alter user ching password expire account lock;

--用户解锁
alter user ching account unlock;

-- 解锁用户并且修改密码
alter user sys account unlock identified by "123456";

-- 解锁用户并且修改密码
alter user system account unlock identified by "&&systempassword";

-- 设置用户密码无限次尝试登录，而该用户不会被锁定
alter profile default limit failed_login_attempts unlimited;

-- 设置用户密码不过期
-- 将密码有效期由默认的180天修改成"无限制"
alter profile default limit password_life_time unlimited;

-- 查看用户的proifle是哪个，一般是default
select username,profile from dba_users;

-- 查看指定概要文件（如default）的密码有效期设置
select * from dba_profiles s where s.profile='default' and resource_name='password_life_time';

-- 修改之后不需要重启动数据库，会立即生效
-- 修改后，没有提示ora-28002警告的帐户,不会再碰到同样的提示
-- 提示的帐户必须再改一次密码
alter user ching identified by "123456" ----不用换新密码


-- 3.授权用户（赋值权限）
grant create session, restricted session to scott;

grant connect,resource,dba to ching;

grant create session to ching;

grant create table to ching;   

grant create tablespace to ching; 
    
grant create view to  ching;


-- 4.撤销用户授权
-- 收回查询select表的权限； 
revoke select on table1 from ching; 
revoke connect from ching 
revoke all on table1 from ching;


-- （1）查找还在使用临时表的会话
select sid, serial# from v$session
where sid = (select sid from v$lock
where id1 = (select object_id  from user_objects
where object_name = upper('你的临时表名')));

-- （2）使用上面查出的sid和serial#，杀掉会话
 alter system kill session 'sid,serial#';


-- 5.创建数据库
-- 手动创建数据库
/*第1步：创建临时表空间  */
create temporary tablespace user_temp  
tempfile 'd:\oracle\oradata\oracle9i\user_temp.dbf' 
size 50m  
autoextend on  
next 50m maxsize 20480m  
extent management local;  
 
/*第2步：创建数据表空间  */
create tablespace user_data  
logging  
datafile 'd:\oracle\oradata\oracle9i\user_data.dbf' 
size 50m  
autoextend on  
next 50m maxsize 20480m  
extent management local;  
 
/*第3步：创建用户并指定表空间  */
create user username identified by password  
default tablespace user_data  
temporary tablespace user_temp;  
 
/*第4步：给用户授予权限  */
grant connect,resource,dba to ching;

-- 修改数据库名称
alter database rename global_name to "bar2008";


-- ==================================================================================
/*
详细说明手工创建oracle数据库实例
手工建库比起使用dbca建库来说，是比较麻烦的，但是如果我们学好了手工建库的话，就可以使我们更好地理解oracle数据库的体系结构。
手工建库须要经过几个步骤，每一个步骤都非常关键。它包括：
１、 创建必要的相关目录
２、 创建初始化参数文件
３、 设置环境变量oracle_sid
４、 创建实例
５、 创建口令文件
６、 启动数据库到nomount(实例)状态
７、 执行建库脚本
８、 执行catalog脚步本创建数据字典
９、 执行catproc创建package包
１０、 执行pupbld
１１、 由初始化参数文件创建spfile文件
１２、 执行scott脚本创建scott模式

 

做完了以上的步骤之后就可以使用"sql>alter database open;"打开数据库正常的使用了。
下面，我将具体地把以上的几个步骤用实验展开来讲。
实验系统平台：windows server 2000　　　数据库系统版本：oracle database 10ｇ
oracle的安装路径：d盘　　　　　 　    创建的数据库名称：book

１、打开命令行工具，创建必要有相关目录
c:\>mkdir d:\oracle\product\10.1.0\admin\book
c:\>mkdir d:\oracle\product\10.1.0\admin\book\bdump
c:\>mkdir d:\oracle\product\10.1.0\admin\book\udump
c:\>mkdir d:\oracle\product\10.1.0\admin\book\cdump
c:\>mkdir d:\oracle\product\10.1.0\admin\book\pfile
c:\>mkdir d:\oracle\product\10.1.0\admin\book\create
c:\>mkdir d:\oracle\product\10.1.0\oradata\book
上面创建目录的过程也可以在windows的图形界面中去创建。其中d:\oracle\product\10.1.0\admin\book目录
下的几个子目录主要用于存放数据库运行过程中的跟踪信息。最重要的两上子目录是bdump和udump目录，
bdump目录存放的是数据库动行过程中的各个后台进程的跟踪信息，当中alert文件是警告文件，其文件名称为alert_book.log，
当数据库出现问题时，首先就可以去查看此文件以找出原因，手工创建过程中出现的各种问题往往也可以通过查看这个文件找到原因。
udump目录存放和特定会话相关的跟踪信息。d:\oracle\product\10.1.0\oradata\book目录存放各种数据库文件，包括控制文件、
数据文件、重做日志文件。

 

2、创建初始化参数文件
数据库系统启动时须要用初始化参数文件的设置分配内存、启动必要的后台进程的。因此，初始化参数文件创建的是否正确、
参数设置是否正确关系着整个建库的"命运"。
创建初始化参数文件可以通过拷贝现在的初始化参数文件并将其做适当的修改即可，从而不必要用手工去一句一句地写出来，
因为初始化参数文件的结构体系基本上都是一样的。在我们安装oracle的时候，系统已经为我们安装了一个名为orcl的数据库，
于是我们可以从它那里得到一份初始化参数文件。

打开d:\oracle\product\10.1.0\admin\orcl\pfile，找到init.ora文件，把它拷贝到d:\oracle\product\10.1.0\bd_1\databse下，
并将其改名为initbook.ora。接着用记事本的方式打开initbook.ora，修改以下的内容：
db_domain=""

db_name=book

control_files=("d:\oracle\product\10.1.0\oradata\book\control01.ctl","d:\oracle\product\10.1.0\oradata\book\control02.ctl",
"d:\oracle\product\10.1.0\oradata\book\control03.ctl")
undo_management=auto
undo_tablespace=undotbs1　――注意此处的"undotbs1"要和建库脚步本中对应
background_dump_dest=d:\oracle\product\10.1.0\admin\book\bdump
core_dump_dest=d:\oracle\product\10.1.0\admin\book\cdump
user_dump_dest=d:\oracle\product\10.1.0\admin\book\udump
 

３、打开命令行，设置环境变量oracle_sid
c:\>set oracle_sid=book
设置环境变量的目地是在默认的情况下，指定命令行中所操作的数据库实例是book。
 

４、创建实例（即后台控制服务）
c:\>oradim –new –sid book
oradim是创建实例的工具程序名称，-new表明执行新建实例，-delete表明执行删掉实例，-sid指定害例的名称。
 

５、创建口令文件
c:\>orapwd file=d:\oracle\product\10.1.0\db_1\database\pwdbook.ora password=bookstore entries=2

orapwd是创建口令文件的工肯程序各称，file参数指定口令文件所在的目录和文件名称，password参数指定sys用户的口令，
entries参数指定数据库拥用dba权限的用户的个数，当然还有一个force参数，相信您不指即明，这里就不再细述。

请注意，这里的命令要一行输入，中间不得换行，否则会出现不必要的错误。
口令文件是专门存放sys用户的口令，因为sys用户要负责建库、启动数据库、关闭数据库等特殊任务，把以sys用户的中令单独存放于口令文件中，
这样数据库末打开时也能进行口令验证。
 

6、启动数据库到nomount(实例)状态
c:\>sqlplus /nolog
sql*plus:release 10.1.0.2.0 - production on 星期三 6月 29 23:09:35 2005
copyright 1982,2004,oracle. all rights reserved.
sql>connect sys/bookstore as sysdba ---这里是用sys连接数据库
已连接到空闲例程
sql>startup nomount
oracle 例程已经启动。
total system global area 319888364bytes
fixed size 453612bytes
variable size 209715200bytes
database buffers 109051904bytes
redo buffers 667648bytes
sql>
 

7、执行建库脚本
执行建库脚本，首先要有建库的脚本。（去哪找建库脚本呢？我又没有！）不用着急，请接着往下看。
得到一个符合自己要求的建库脚本有两种方法，一种方法是在自己的电脑上用dbca来建，接照它的提示一步步地去做，
在做到第十二步的时候，请选择"生成建库脚本"，然后就大功告成，你就可以到相应的目录上去找到那个脚本并适当地修它便可便用。
另一种方法就是自己手工去写一份建库脚本，这也是这里要见意使用的方法，用记事本编辑如下的内容，
并将其保存为文件名任取而后缀名为（*.sql）的sql脚本，这里保存到e盘根本录下且文件名称为book.sql。

create database book
datafile 'd:\oracle\product\10.1.0\oradata\book\system01.dbf' size 300m reuse autoextend on next 10240kmaxsize unlimited
extent management local
sysaux datafile 'd:\oracle\product\10.1.0\oradata\book\sysaux01.dbf'
size 120m reuse autoextend on next 10240k maxsize unlimited
default temporary tablespace temp
tempfile 'd:\oracle\product\10.1.0\oradata\book\temp01.dbf' size 20m reuse autoextend on next 640k maxsize unlimited
undo tablespace "undotbs1" --请注意这里的undo表空间要和参数文件对应
datafile 'd:\oracle\product\10.1.0\oradata\book\undotbs01.dbf' size 200m reuse autoextend on next 5120k maxsize unlimited
logfile
group 1 ('d:\oracle\product\10.1.0\oradata\book\redo01.log') size 10240k,
group 2 ('d:\oracle\product\10.1.0\oradata\book\redo02.log') size 10240k,
group 3 ('d:\oracle\product\10.1.0\oradata\book\redo03.log') size 10240k

接着就执行刚建的建库脚本：
sql>start e:\book.sql
 

8、执行catalog脚步本创建数据字典
sql>start d:\oracle\product\10.1.0\db_1\rdbms\admin\catalog.sql
 

9、执行catproc创建package包
sql>start d:\oracle\product\10.1.0\db_1\rdbms\admin\catproc.sql
 

10、执行pupbld
在执行pupbld之前要把当前用户（sys）转换成system,即以system账户连接数据库。因为此数据库是刚建的，
所以system的口令是系统默认的口令，即manager。你可以在数据库建好以后再来重新设置此账户的口令。

sql>connect system/manager
sql>start d:\oracle\product\10.1.0\db_1\sqlplus\admin\pupbld.sql
 

11、由初始化参数文件创建spfile文件
sql>create spfile from pfile;
 

12、执行scott脚本创建scott模式
sql>start d:\oracle\product\10.1.0\db_1\rdbms\admin\scott.sql
 

13、把数据库打开到正常状态
sql>alter database open;
 

14、以scott连接到数据库（口令为tiger），测试新建数据库是否可以正常运行
至此，整个数据库就已经建好了。接着你就可以在此数据库上建立自己的账户和表空间啦以及数据库对象，这里就不再作更多地叙述。
 

总结：作为一般开发人员来说，我们推荐使用第一种方式来建立oracle数据库实例。方便快捷不易出错。
但作为高级开发人员或dba来说手工安装可以为更深入了解oracle的结构。
此处作为初学者。我们还是建议使用第一种界面安装方式来安装新的数据库实例。


========================================================================================
创建数据库文件
create tablespace mydatabase logging datafile 'd:\oracle\database\mydatabase.dbf' size 100m autoextend 
on next 32m maxsize 500m extent management local;
 

mydatabase:数据库名称
d:\oracle\database\mydatabase.dbf：数据库文件目录

创建数据库临时文件
create temporary tablespace mydatabase_temp tempfile 'd:\oracle\database\mydatabase_temp.dbf' size 100m autoextend 
on next 32m maxsize 500m extent management local;
 

mydatabase_temp：数据库临时文件名称
d:\oracle\database\mydatabase_temp.dbf：数据库临时文件目录
创建用户与上述两个文件形成映射关系
create user username identified by password default tablespace mydatabase temporary tablespace mydatabase_temp;
 

username：用户名
password：密码
mydatabase：映射的数据库名称
mydatabase_temp：映射的数据库临时文件名称
添加用户权限
grant connect,resource,dba to ching;
grant create session to ching;
删除数据库
conn sys/123456 as sysdba;
drop tablespace mydatabase including contents and datafiles;
drop tablespace mydatabase_temp including contents and datafiles;


删除用户
drop user ching cascade;
========================================================================================
*/


-- 6.创建表结构
create table aaa_tmp_sale_trace as select * from view_sale_trace where 0>1
create table bbb_tmp_sale_trace as select * from sale_trace where 0>1


-- 创建bool类型值例子
create table my_test
(
  id                number(32) not null,
  userid            number(32) not null,
  isenable          char check (isenable in (0,1))
)
tablespace users
pctfree 10
initrans 1
maxtrans 255
storage
(
  initial 64k
  minextents 1
  maxextents unlimited
);
-- add comments to the table 
comment on table my_test
  is '我的测试表';
-- add comments to the columns 
comment on column my_test.id
  is '主键';
comment on column my_test.userid
  is '用户id';
comment on column my_test.isenable
  is '是否启用';



create table base_config
(
  id              number(32) not null,
  companyname     varchar2(100),
  shortname       varchar2(30),
  copyright       varchar2(50),
  lowrecord       varchar2(50),
  contracttel     varchar2(50),
  logo            varchar2(100),
  createtime      date not null,
  createuserid    number(32) not null,
  createusername  nvarchar2(100),
  operateuserid   number(32) not null,
  operateusername nvarchar2(100),
  operatetime     date not null,
  isdelete        char(1) default 0 not null,
  deletetime      date
)
tablespace users
pctfree 10
initrans 1
maxtrans 255;
-- add comments to the table 
comment on table base_config
  is '站点配置表';
-- add comments to the columns 
comment on column base_config.id
  is '主键';
comment on column base_config.companyname
  is '公司名称';
comment on column base_config.shortname
  is '简称';
comment on column base_config.copyright
  is '版权所有';
comment on column base_config.lowrecord
  is 'lowrecord';
comment on column base_config.contracttel
  is '联系人电话';
comment on column base_config.logo
  is 'logo';
-- create/recreate primary, unique and foreign key constraints 
alter table base_config
  add constraint pk_base_config primary key (id)
  using index 
  tablespace users
  pctfree 10
  initrans 2
  maxtrans 255;


-- create table
create table base_log
(
  id             number(32) not null,
  userid         number(32) not null,
  username       nvarchar2(100),
  clientip       varchar2(100),
  serverip       varchar2(100),
  webip          varchar2(100),
  modulename     nvarchar2(50),
  actionname     nvarchar2(50),
  content        nvarchar2(1000),
  createuserid   number(32),
  createusername nvarchar2(100),
  createtime     date not null,
  opuserid       number(32) not null,
  opusername     nvarchar2(100),
  optime         date not null,
  isdelete       char(1) default 0 not null,
  deletetime     date
)
tablespace users
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64k
    next 1m
    minextents 1
    maxextents unlimited
  );
-- add comments to the table 
comment on table base_log
  is '系统日志表';
-- add comments to the columns 
comment on column base_log.id
  is '主键';
comment on column base_log.userid
  is '用户id';
comment on column base_log.username
  is '用户名';
comment on column base_log.clientip
  is '客户端 ip';
comment on column base_log.serverip
  is '服务 ip';
comment on column base_log.webip
  is '站点 ip';
comment on column base_log.modulename
  is '模块名称';
comment on column base_log.actionname
  is '操作名称';
comment on column base_log.content
  is '日志内容';
comment on column base_log.createuserid
  is '创建人 id';
comment on column base_log.createusername
  is '创建人名称';
comment on column base_log.createtime
  is '创建时间';
comment on column base_log.opuserid
  is '最后操作人id';
comment on column base_log.opusername
  is '最后操作人';
comment on column base_log.optime
  is '最后操作时间';
comment on column base_log.isdelete
  is '是否删除';
comment on column base_log.deletetime
  is '删除时间';
-- create/recreate primary, unique and foreign key constraints 
alter table base_log
  add constraint pk_base_log primary key (id)
  using index 
  tablespace users
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64k
    next 1m
    minextents 1
    maxextents unlimited
  );



-- 修改表
-- create/recreate primary, unique and foreign key constraints 
alter table reward_scheme
  add primary key (reward_id)
  using index 
  tablespace users
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64k
    minextents 1
    maxextents unlimited
  );



-- 7.查询表数据  查询数据
select * from games_info@mydblink.regress.rdbms.dev.us.oracle.com
where rownum <= 100

-- 取10条记录
select * from syn_xods_bosdb_item
where rownum <= 10

select to_char(date1, 'mmddyyyy:hh24:mi:ss') date1,
       to_char(date2, 'mmddyyyy:hh24:mi:ss') date2,
       trunc(86400 * (date2 - date1)) -
       60 * (trunc((86400 * (date2 - date1)) / 60)) seconds,
       trunc((86400 * (date2 - date1)) / 60) -
       60 * (trunc(((86400 * (date2 - date1)) / 60) / 60)) minutes,
       trunc(((86400 * (date2 - date1)) / 60) / 60) -
       24 * (trunc((((86400 * (date2 - date1)) / 60) / 60) / 24)) hours,
       trunc((((86400 * (date2 - date1)) / 60) / 60) / 24) days,
       trunc(((((86400 * (date2 - date1)) / 60) / 60) / 24) / 7) weeks
  from date_table

-- date1 date2 seconds minutes hours days weeks 
-- ----------------- ----------------- ---------- ---------- ---------- ---------- ---------- 
-- 06202003:16:55:14 07082003:11:22:57 43 27 18 17 2 
-- 06262003:11:16:36 07082003:11:22:57 21 6 0 12 1


-- 子查询（嵌套查询）
-- 嵌套子查询
select * from 
(
    select id,imagename,toprow,topvalue,bottomrow,bottomvalue,leftcolumn,leftvalue,rightcolumn,rightvalue,path,
    udvalue,udpos,lrvalue,lrpos,
    switch(udvalue > lrvalue,udvalue,udvalue<=lrvalue,lrvalue) as result
    from
    (
         select id,imagename,toprow,topvalue,bottomrow,bottomvalue,leftcolumn,leftvalue,rightcolumn,rightvalue,path,
         switch(topvalue > bottomvalue,topvalue,topvalue <= bottomvalue,bottomvalue) as udvalue,
         switch(leftvalue > rightvalue,leftvalue,leftvalue <= rightvalue,rightvalue) as lrvalue,
         switch(topvalue > bottomvalue,1,topvalue <= bottomvalue,2) as udpos,
         switch(leftvalue > rightvalue,3,leftvalue <= rightvalue,4) as lrpos 
         from imagehandle
    )
)
order by result desc


-- 左连接查询
select rml.id,rml.hospital_id,rml.microscope_number,rml.is_enabled as enabled,rml.remark,rh.name 
from rmp_microscope_list rml left join rmp_hospitals rh on rml.hospital_id = rh.id
where microscope_number like '%sx%' and rh.id=27
order by rml.id desc


-- 嵌套联合子查询
select pi.part_no,pi.batch_code,pi.part_b,pi.prod_mfr,si.unit_qty,
  si.local_stock_count,si.sale_stock_count,si.amortize_price,vow.onway_qty
  from
  (
     select part_no,batch_code,part_b,prod_mfr
     from 
     (
        select part_a,part_b from pro_replace 
        union
        select b.part_a,a.part_b from pro_replace a, 
        (
           select part_a,part_b from pro_replace
        ) b 
        where a.part_a in 
        (
           select part_b from pro_replace
        ) 
        and a.part_a=b.part_b
     ) pr left join product_info pi
     on pr.part_a = pi.part_no
  ) pi left join
  (
    select distinct(si.part_no),(l.unit_qty + s.unit_qty) as unit_qty,
    l.unit_qty as local_stock_count,
    s.unit_qty as sale_stock_count,
    ls.amortize_avg as amortize_price
    from stock_info si,
    (
      select part_no,sum(unit_qty) as unit_qty from stock_info where cmd_id in 
      (
        select cmd_name from cust_manu_depot t
        where cmd_type='库房' and tax_no = '本地库'
      )
      group by part_no
    ) l,
    (
      select part_no,sum(unit_qty) as unit_qty from stock_info where cmd_id in 
      (
        select cmd_name from cust_manu_depot t
        where cmd_type='库房' and tax_no = '售出库'
      )
      group by part_no
    ) s,
    (
      select part_no,sum(amortize_amount) as amortize_amount,sum(unit_qty) as unit_qty,
      round((sum(amortize_amount)/sum(unit_qty)), 3) as amortize_avg 
      from stock_info where cmd_id in (select cmd_name from cust_manu_depot t
      where cmd_type = '库房' and tax_no in ('本地库','售出库')) and unit_qty > 0
      group by part_no
    ) ls
    where si.part_no = l.part_no and si.part_no = s.part_no and si.part_no = ls.part_no
  ) si
  on pi.part_no = si.part_no 
  left join view_on_way vow
  on pi.part_no = vow.part_no
  where 1 = 1 and part_no in ('m39029-31-229')
  order by part_no


select part_a,part_b from pro_replace 
union
select b.part_a,a.part_b from pro_replace a, 
(
   select part_a,part_b from pro_replace
) b 
where a.part_a in 
(
   select part_b from pro_replace
) 
and a.part_a=b.part_b


--查找某一个件号的关联替换件号有哪些
select part_a,part_b from pro_replace 
where part_a = 'aaa' 
union
select b.part_a,a.part_b from pro_replace a, 
(
   select part_a,part_b from pro_replace where part_a = 'aaa' 
) b 
where a.part_a in 
(
   select part_b from pro_replace where part_a = 'aaa'
) 
and a.part_a=b.part_b


--这个是查出了本地库和出售库的记录
select * from stock_info where cmd_id in (select cmd_name from cust_manu_depot t
where cmd_type='库房' and tax_no in ('本地库','售出库')) 
and part_no=upper('01017895')


--计算出摊销单价
select part_no,sum(amortize_amount) as amortize_amount,sum(unit_qty) as unit_qty,
round((sum(amortize_amount)/sum(unit_qty)),3) as amortize_avg
from stock_info where cmd_id in (select cmd_name from cust_manu_depot t
where cmd_type = '库房' and tax_no in ('本地库','售出库')) and unit_qty > 0
--and part_no = upper('01017895')
group by part_no


--计算出本地库的库存
select part_no,sum(unit_qty) as unit_qty from stock_info 
where cmd_id in 
(
  select cmd_name from cust_manu_depot t
  where cmd_type='库房' and tax_no = '本地库'
)
and part_no=upper('01017895')
group by part_no


--计算出售出库的库存
select part_no,sum(unit_qty) as unit_qty from stock_info 
where cmd_id in 
(
  select cmd_name from cust_manu_depot t
  where cmd_type='库房' and tax_no = '售出库'
) 
and part_no=upper('01017895')
group by part_no


--distinct去掉重复记录的
--查询本地库和售出库库存总和
select distinct si.part_no,(l.unit_qty + s.unit_qty) as unit_qty,
l.unit_qty as local_stock_count,
s.unit_qty as sale_stock_count,
si.amortize_price
from stock_info si,
(
  select part_no,sum(unit_qty) as unit_qty from stock_info 
  where cmd_id in 
  (
    select cmd_name from cust_manu_depot t
    where cmd_type='库房' and tax_no = '本地库'
  )
  group by part_no
) l,
(
  select part_no,sum(unit_qty) as unit_qty from stock_info 
  where cmd_id in 
  (
    select cmd_name from cust_manu_depot t
    where cmd_type='库房' and tax_no = '售出库'
  )
  group by part_no
) s
where cmd_id in 
(
  select cmd_name from cust_manu_depot t
  where cmd_type='库房' and tax_no in ('本地库','售出库')
)
and si.part_no = l.part_no and si.part_no = s.part_no 
and si.part_no=upper('01017895')
--group by si.part_no

select * from purchaseorder_view 
where rest_qty>0 and lower(part_no) like '%e0242a115b0%'


-- 嵌套右连接子查询
select part_no,batch_code,part_b,pi.cmd_name as prod_mfr 
from (
     select part_a,part_b from pro_replace union select b.part_a,a.part_b from pro_replace a,  
     (select part_a,part_b from pro_replace) b where a.part_a in (select part_b from pro_replace) and a.part_a=b.part_b
     ) pr 
     right join (select pi.*,cmd.cmd_name from product_info pi left join cust_manu_depot cmd on cmd.cmd_id in pi.prod_mfr) pi
on pr.part_a = pi.part_no where upper(pi.part_no) in ('abs0336-08')


select pi.part_no,max(pi.batch_code) batch_code,max(pi.part_b) part_b,max(pi.prod_mfr) prod_mfr,
max(si.unit_qty) unit_qty,max(si.local_stock_count) local_stock_count,max(si.sale_stock_count) sale_stock_count,
sum(vow.onway_qty) onway_qty,max(si.amortize_price) amortize_price 
from 
(
  select part_no,batch_code,part_b,pi.cmd_name as prod_mfr 
  from (select part_a,part_b from pro_replace union select b.part_a,a.part_b from pro_replace a,
  (select part_a,part_b from pro_replace) b where a.part_a in (select part_b from pro_replace) and a.part_a=b.part_b  ) pr 
  right join (select pi.*,cmd.cmd_name from product_info pi left join cust_manu_depot cmd on cmd.cmd_id in pi.prod_mfr) pi  
  on pr.part_a = pi.part_no
) pi 
left join 
(
  select distinct(si.part_no),(l.unit_qty + s.unit_qty) as unit_qty,
  l.unit_qty as local_stock_count, s.unit_qty as sale_stock_count, ls.amortize_avg as amortize_price 
  from stock_info si left join 
  (
    select part_no,sum(unit_qty) as unit_qty from stock_info where cmd_id in  
    (select cmd_name from cust_manu_depot t where cmd_type='库房' and tax_no = '本地库') group by part_no
  ) l on si.part_no = l.part_no left join
  ( 
    select part_no,sum(unit_qty) as unit_qty 
    from stock_info 
    where cmd_id in 
    (
      select cmd_name from cust_manu_depot t 
      where cmd_type='库房' and tax_no = '售出库' 
    ) 
    group by part_no
  ) s on si.part_no = s.part_no left join
  (
    select part_no,sum(amortize_amount) as amortize_amount,
    sum(unit_qty) as unit_qty,round((sum(amortize_amount)/sum(unit_qty)), 3) as amortize_avg  
    from stock_info 
    where cmd_id in (select cmd_name from cust_manu_depot t where cmd_type = '库房' and tax_no in ('本地库','售出库')) 
    and unit_qty > 0 group by part_no 
  ) ls on si.part_no = ls.part_no
) si 
on pi.part_no = si.part_no left join view_on_way vow on pi.part_no = vow.part_no where 1 = 1  
and upper(pi.part_no) in ('145-101-174') group by pi.part_no order by pi.part_no 



--取随机的数据
select empno,ename from ( select a.*,rownum rn from emp a order by dbms_random.value ) where rn<2;
select id,cuscode,cusname from ( select a.*,rownum rn from cpms_customer a order by dbms_random.value ) where rn<2;

--coalesce 将空转为0  --推荐用此方法 返回第一个不为空的表达式，如果都为空则返回空值。
select a.*,coalesce(comm,0)comm from emp a where empno=7369 ;  
select coalesce(null,3+5,4+6) value from dual; 
select a.*,nvl(comm,0)comm from emp a where empno=7369 ;  

--like查询下划线开头的字符
update emp set ename='_'||job where empno=7788;
-- select * from emp where ename like '\_%' escape '\';


--从右向左截取 substr
select a.*,substr(job,-2) from emp a where empno=7369;    --从右边第一位开始，截取2 位
select a.*,substr(job,-2,1) from emp a where empno=7369;  --从右边第二位开始，截取 1位

--order by 中用 case when 
select empno,sal,case when sal >= 3000 then 1 else 2 end as rn from emp order by 3 ,2 desc; 
select empno,sal  from emp order by case when sal>=3000 then 1 else 2 end,2 desc; 


-- translate 函数  translate(字段,from_string,to_string) 如果 from_string 比to_string 长
-- from_string中有而 to_string没有的，这些没有的字符将从字段中被替换为空，也就是删除的意思，9i,10g 11g 都适用
select prid,praddr,translate(praddr,'a 0123456789','a') from prov; 

select translate('afdfadf你好','1你好','1') from dual; 
select translate('afdfadf你好','12你好','21') from dual; 
-- 结果：afdfadf


-----------------------------------------------------------------------------------------------------------------------
--正则表达式用法示例
-- regexp_replace  如果字符中既有数字也有汉字，可以用如下方式提取数字和汉字

--提取汉字
select prid,praddr,regexp_replace(praddr,'[0-9]')rn from prov where prid=100252;

--提取数字
select prid,praddr,regexp_replace(praddr,'[^0-9]')rn from prov where prid=100252;


--regexp_like  查找 ename 中有 A 字符的
select * from emp where regexp_like(ename,'A');
select * from emp where regexp_like(ename,'a','i');  --i 不区分大小写 ，c 区分大小写，默认为区分大小写

--查找 以A开头的
select * from emp where regexp_like(ename,'^A');

--查找 以 N 结尾的
select * from emp where regexp_like(ename,'N$');

--查找包含下划线的
select * from emp where regexp_like(ename,'_');

---regexp_substr
select a.*,regexp_substr(ename,'A',1,1,'i')rn from emp a where empno=7499; 

 --以一个或以上逗号开头，从第一位开始，第一次出现的位置，下面截取左边的 34 
SELECT REGEXP_SUBSTR('34,56,-23','[^,]+',1,1,'i') AS STR FROM DUAL; 


--分段截取数字
SELECT REGEXP_SUBSTR('34,56,-23', '[^,]+', 1, LEVEL, 'i') AS STR
  FROM DUAL  
CONNECT BY LEVEL <=  
           LENGTH('34,56,-23') - LENGTH(REGEXP_REPLACE('34,56,-23', ',', ''))+1;  



--regexp_instr 某个字符串出现的位置
Select instr('avdsdabasdab','a',1,2)rn FROM DUAL; 
select regexp_instr('avdsdabasdab','a',1,3)rn  from dual; --从第一位开始，查找a第三次出现的位置

--regexp_count  某个字符串出现的次数
select regexp_count ('The pro-niece was born today, so exciting!', 'o', 23, 'i')rn from dual;


---------------------------------------------------------------------------------------------------------------------------------------------------

--闪回版本查询及 闪回事物查询
select * from emp; 
update scott.emp set comm=1000

--查所有时间闪回版本查询
select versions_starttime, versions_endtime, versions_xid, 
versions_operation, empno 
from scott.emp versions between timestamp minvalue and maxvalue
order by VERSIONS_STARTTIME

--按时间段查
select empno, versions_starttime, versions_endtime,versions_xid
from scott.emp versions
between timestamp 
to_date('2015-03-23 16:15:00','yyyy-mm-dd hh24:mi:ss')
and to_date('2015-03-23 16:19:00','yyyy-mm-dd hh24:mi:ss')

--闪回事物查询
alter database add supplemental log data;  --启用最小补充日志
select *  from flashback_transaction_query  where table_owner='SCOTT' and xid='08000D0014030000'














-- 8.修改
update imageaverage set average = 56 where patid = 20150514001

update rmp_microscope_list set id=22,hospital_id='1',microscope_number='sxxa5048',is_enabled='n',remark='高倍绿光显微镜' 
here hospital_id=1 and microscope_number='sxxa5048'


--更新在途数量
update purchaseorder_view_table pvt set onway_qty = 
(
  select sum(onway_qty) as onway_qty 
  from view_on_way vow 
  where 1=1 and pvt.part_no = vow.part_no(+)
  group by part_no
)


--全部更新()
update purchaseorder_view_table pvt set (onway_qty,stock_unit_qty,history_cost,lasted_supplier)=
(
  select onway_qty,stock_unit_qty,history_cost,lasted_supplier
  from  
  (
    select part_no,sum(onway_qty) as onway_qty 
    from view_on_way vow 
    where 1=1
    group by part_no
  ) vow,
  (
    select part_no,sum(unit_qty) as stock_unit_qty 
    from stock_item si 
    where 1=1
    group by part_no
  ) si,
  (
    select distinct(di.part_no),di.sale_price as history_cost,db.cmd_id as lasted_supplier,di.apply_date,di.deal_id
    from deal_bill db,deal_item di,
    (
      select part_no,max(deal_id) as deal_id
      from deal_item 
      where 1=1 and substr(deal_id,0,1)='p' 
      group by part_no
    ) mdpn
    where db.deal_id = di.deal_id and substr(db.deal_id,0,1)='p'
    and lower(mdpn.part_no) = lower(di.part_no(+))
    and lower(mdpn.deal_id) = lower(di.deal_id)
  ) di  
  where vow.part_no = pvt.part_no
  and si.part_no = pvt.part_no
  and di.part_no = pvt.part_no 
)

-- 更新大表数据 update大数据表
declare
  cursor cur_t is
    select rowid rid from tpr_zwjyw3 where dwid=10113222;
  type tab_t is table of urowid index by binary_integer;
  l_rid tab_t;
begin
  open cur_t;
  loop
    fetch cur_t bulk collect
      into l_rid limit 45000;
    forall idx in 1 .. l_rid.count
      update tpr_zwjyw3 t set t.zh ='没有' where rowid = l_rid(idx);
    commit;
    exit when cur_t%notfound;
  end loop;
  close cur_t;
end;
-- 千万级别的数据 update 或delete  效果明显



-- 如果要DML实现真正意义上的并发，在开始执行需要并发语句前，需要执行开启session并发  ALTER SESSION ENABLE PARALLEL DML;  
-- 在执行完语句后，需要执行关闭session并发  ALTER SESSION DISABLE PARALLEL DML;

-- 使用并行，加快大量数据更新：
-- Oracle 对Delete,update,merge的操作限制在，只有操作的对象是分区表示，Oracle 才会启动并行操作。
-- 原因在于，对于分区表，Oracle 会对每个分区启用一个并行服务进程同时进行数据处理，这对于非分区表来说是没有意义的。

merge /*+parallel(test1,4)*/ into test1 using test2
on (test1.id = test2.id)
when matched then update set test1.name = nvl2(test1.name,test2.name,test1.name);
 

merge into tpr_fwzh1 a  
using tpr_zwjjx_jxcll b 
on (a.fwcode=b.fwcode and a.zjlx=b.zjlx) 
when matched then update set a.zhye=b.dqye,a.lxye=a.lxye+b.jxlx




-- 创建表 带数据
create table b as select * from a;

-- 创建表 不带数据
create table b as select * from a where 1=2;


-- 存在一个表b和表a的表结构一致，将a中的数据复制给b表
insert into b select * from a;

-- 存在一个表b和表a的表结构不一致，将a中的数据复制给b表
insert into b (x1,x2,x3...) select x1,x2,x3... from a;


-- 同一个表，将a字段的值赋值为b字段
update userinfo set b = a


-- 9.新增数据，插入数据
insert into userinfo(id, name, sex, age, remark) values(1, 'flack', 1, 20, '博士生导师');

insert into userinfo values(1, 'flack', 1, 20, '博士生导师');

-- 表不存在
-- pl/sql
create table userinfo as select * from users;

-- t-sql
-- 目标表table2不存在，因为在插入时会自动创建表table2，并将table1中指定字段数据复制到table2中
select value1, value2 into table2 from table1


-- 表存在
insert into table2(a, c, d) select a,c,5 from table1 
-- 或：
insert into table2 select * from table1

-- 查询一个表的数据插入到另一个表
insert into userinfo select * from users;


-- 将一个表的字段数据插入到另一个表的字段数据中
insert into userinfo(id, name, sex) select id,name,sex from users
--如果报提醒：ora-00928: 缺失 select 关键字错误
--原因是：这里tab1(field1,field2,....)不能加单引号

-- 多个表的多个字段，插入同一个表的多个字段
insert into button_tab (button_id, button_name, button_code) 
select a.pk_examquest, b.pk_bdversion,a.vquestname  
from  dsknow.combdversion b ,dsknow.rqt_examquest a  
where a.pk_examquest='1001sx1000000000jobv' 
and b.pk_bdversion='1000bdv1000010101001';


-- 10.删除记录
delete from imagehandle

-- 将一个列标识为unused
-- 然后在系统负载比较轻的时候使用
alter table drop unused columns

-- 删除表
drop table purchaseorder_view_table purge;

-- 删除记录
truncate table aaa_tmp_stock_info



-- 删除大表数据
declare  
   cursor mycursor is SELECT ROWID FROM tpr_zjjx1 WHERE jxrq=to_date('2013-06-30','yyyy-mm-dd') order by rowid;  
   type rowid_table_type is table of rowid index by pls_integer;
   v_rowid rowid_table_type;
BEGIN
   open mycursor;
   loop
     fetch mycursor bulk collect into v_rowid  limit 5000;   
     exit when v_rowid.count=0;
     forall i in v_rowid.first..v_rowid.last
        delete from tpr_zjjx1  where rowid=v_rowid(i);
     commit;
   end loop;
   close mycursor;
END;






-- 11.创建视图
--创建视图
create or replace force view "hr"."v_reg_cou" ("r_id", "r_name", "c_id", "c_name")
as
select r.region_id,
    r.region_name,
    c.country_id,
    c.country_name
from regions r,
    countries c
where r.region_id = c.region_id;


-- 创建物化视图
create materialized view emp1 
refresh complete
start with sysdate
next sysdate + 1/1440
as 
with t as 
(
  select a.ename,a.sal,b.dname from scott.emp a 
  inner join scott.dept b on a.deptno=b.deptno
  order by b.dname       
)
select * from t


-- 12.创建索引
-- 单一索引:
create index idx_rko_fmlg_dt On userinfo(id);

-- 复合索引: 
-- 在emp表的deptno、job列建立索引。
Create Index idx_deptno_job on emp(deptno, job); 

-- eg：
select * from emp where deptno=66 and job='sals' ->走索引。

select * from emp where deptno=66 OR job='sals' ->将进行全表扫描。不走索引

select * from emp where deptno=66 ->走索引。

select * from emp where job='sals' ->进行全表扫描、不走索引。
-- 如果在where 子句中有OR 操作符或单独引用Job 列(索引列的后面列) 则将不会走索引，将会进行全表扫描。

-- 删除索引
drop index "idx_deptno_job"


-- 13.创建dblink
--ora-01031：权限不足
grant sysdba to hccpms
--创建database_link 远程连接数据库
create database link mydblink
connect to bruce identified by "123456"
using '(description =
      (address_list =
        (address = (protocol = tcp)(host = 192.168.10.126)(port = 1521))
      )
      (connect_data = 
      (sid = test1)
      )
)';


----删除database_link
drop database link mydblink.regress.rdbms.dev.us.oracle.com;



-- 游标
create or replace package mypackage is
type my_cursor is ref cursor;
end mypackage;


create or replace procedure xs_proc_list(v_sjbm number,
p_cursor out mypackage.my_cursor) is
begin
open p_cursor for
select * from tpg_qyxx  where id=v_sjbm ;
end xs_proc_list;


declare 
my1_cursor mypackage.my_cursor;
qyxx tpg_qyxx%rowtype;
begin
DBMS_OUTPUT.ENABLE(buffer_size => null);
xs_proc_list(20037009,my1_cursor);
loop
 fetch my1_cursor into qyxx; 
 exit when my1_cursor%notfound;
 dbms_output.put_line(qyxx.qymc||'   '||qyxx.fzr);
  end loop;
end;



-- 一、存储过程中使用动态SQL
create or replace procedure insertt(v_deptno number,v_dname varchar2,v_loc varchar2)
is
begin
  execute immediate 'insert into dept values(:1,:2,:3)' using v_deptno,v_dname,v_loc;
  commit;
end;


-- 存储过程中使用动态SQL创建表,注意点，当前用户一定要有create any table 的权限，否则无法创建
create or replace procedure inserta
is
v_tablename varchar2(100);
begin
  select upper('tablename_')||replace(to_char(sysdate,'yyyy-mm-dd'),'-','') into v_tablename  from dual;
  execute immediate 'create table '||v_tablename||'(id number, name varchar2(10))';
end;

-- 以下这种形式也可以，但是必也要有 create any table 权限才能够创建；
create or replace procedure insertb
is
v_tablename varchar2(100);
v_sql varchar2(1000);
begin
  select upper('tablename')||replace(to_char(sysdate,'yyyy-mm-dd'),'-','') into v_tablename  from dual;
  v_sql:= 'create table '||v_tablename||'(id number, name varchar2(10))';
  execute immediate v_sql;
end;

----------------------------------------------------------------------------------------------------------------------------

-- 二、写一个存储过程用于判断一个用户下各表中有多少条数据，然后放入到一张新建的表中；

-- 1、用游标编写
declare 
cursor cur_table is
select table_name from user_tab_comments;
v_num number;
v_table varchar(20);
v_sql varchar(200);
begin
  open cur_table;
  loop
    fetch cur_table into v_table;
    EXIT WHEN cur_table %NOTFOUND;
   v_sql:= 'select count(1) from ' ||v_table;
   execute immediate v_sql into v_num;
    insert into  table_num values(v_table,v_num);
    end loop;
    close cur_table;
    commit;
end;


execute immediate v_sql into v_num;  可以直接写成
execute immediate 'select count(1) from ' ||v_table into v_num;
--------------------------------------------------------------------

-- 2、用存储过程编写
create or replace procedure tj_data is  
  -- 当前存储过程用到的变量
  v_tableName VARCHAR2(100);
  v_sql  varchar2(200);
  v_count integer;
  -- 获取当前数据库中的所有表
  CURSOR TABLE_LOOP IS SELECT Table_name FROM User_tables;
  BEGIN
    -- 打开游标
    OPEN TABLE_LOOP;
      LOOP
        FETCH TABLE_LOOP INTO v_tableName;
          EXIT WHEN TABLE_LOOP %NOTFOUND;
              v_sql:= 'select count(1) from '||v_tableName;
              execute immediate v_sql into v_count;
              dbms_output.put_line(v_tableName||':'||v_count);
      END LOOP;
    CLOSE TABLE_LOOP;
end tj_data;

-----------------------------------------------------------------------------------------------------------------------------



-- 三、批量删除一个用户下的表

DECLARE
CURSOR TIANMING_DROP IS 
select TABLE_NAME from user_tables where regexp_like(table_name,'^TIANMING');
HANG varchar2(50);
BEGIN
  open TIANMING_DROP;
  LOOP 
  FETCH TIANMING_DROP INTO HANG;
  exit when TIANMING_DROP%notfound;
  EXECUTE IMMEDIATE  'DROP  TABLE '|| HANG ;
  END LOOP;
  close TIANMING_DROP;
END;
------------------------------------------------------------------------------------
declare 
  cursor cur1 is select table_name from dba_tables where owner='我是用户名';
begin
  for cur2 in cur1 loop
  execute immediate 'drop table 我是用户名.'||cur2.table_name;
  end loop;
end;


-- 四、批量清除回收中的表   purge table 
DECLARE
CURSOR TIANMING_DROP IS 
select original_NAME from recyclebin where regexp_like (original_NAME,'^TIANMING');
HANG varchar2(100);
BEGIN
  open TIANMING_DROP;
  LOOP 
  FETCH TIANMING_DROP INTO HANG;
  exit when TIANMING_DROP%notfound;
  EXECUTE IMMEDIATE  'PURGE  TABLE '||HANG;
  END LOOP;
  close TIANMING_DROP;
END;

-------------------------------------------------------------------------------------------------------------------

--判断表是否存在，如果存在则删除
DECLARE 
TIANMING_NUM  NUMBER; 
BEGIN 
      SELECT COUNT(1) INTO  TIANMING_NUM FROM  USER_TABLES 
      WHERE TABLE_NAME = 'TIANMING_TPF_SYQDJB';
      IF   TIANMING_NUM=1   then 
          EXECUTE IMMEDIATE  'DROP  TABLE TIANMING_TPF_SYQDJB '; 
      END IF; 
END;
COMMIT;

--查询某个表空间下的所有表
select table_name, tablespace_name
  from dba_tables
 where tablespace_name = upper('表空间名');

-------------------------------------------------------------------------------------------------------------------
--将某个用户下的所有授权给一个用户，下面的是授予查询权限

declare cursor cur_a 
is 
select table_name from user_tables;
v_var varchar2(1000);
begin
  open cur_a;
  loop 
    fetch cur_a into v_var;
    exit when cur_a%notfound;
    EXECUTE IMMEDIATE 'grant  select  on ' ||v_var|| ' to  user1 ';
    end loop;
  close cur_a;
end;



--游标删除一个用户下所有表的数据

declare 
cursor cur_trunc is select table_name from user_tables where table_name like 'TPG_B%';
v_tablename varchar2(20);
begin
open cur_trunc;
loop 
fetch cur_trunc into v_tablename;  
exit when cur_trunc%notfound;
execute immediate 'truncate table '||v_tablename;
end loop;
close cur_trunc;
end;


--游标FOR 循环
declare cursor cur_trunc 
is 
select  table_name from user_tables where table_name like 'TPG_Q%';
begin
for cur_del in cur_trunc loop
  execute immediate 'delete from '||cur_del.table_name;
  end loop;
end;




-- 14.创建存储过程
-- 无参存储过程语法
-- create or replace procedure noparpro  
--  as  --声明  
--  ;  
--  begin -- 执行  
--  ;  
--  exception--存储过程异常  
--  ;  
--  end;

-- 带参存储过程实例
-- create or replace procedure queryempname(sfindno emp.empno%type)   
-- as  
--    sname emp.ename%type;  
--    sjob emp.job%type;  
-- begin  
--        ....  
-- exception  
--        ....  
-- end;


-- 带参数存储过程含赋值方式
-- create or replace procedure runbyparmeters    
--     (isal in emp.sal%type,   
--      sname out varchar,  
--      sjob in out varchar)  
--  as   
--     icount number;  
--  begin  
--       select count(*) into icount from emp where sal>isal and job=sjob;  
--       if icount=1 then  
--         ....  
--       else  
--        ....  
--      end if;  
-- exception  
--      when too_many_rows then  
--      dbms_output.put_line('返回值多于1行');  
--      when others then  
--      dbms_output.put_line('在runbyparmeters过程中出错！');  
-- end; 
-- 其中参数in表示输入参数，是参数的默认模式。
-- out表示返回值参数，类型可以使用任意oracle中的合法类型。
-- out模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程
-- in out表示该参数可以向该过程中传递值，也可以将某个值传出去。


-- 存储过程中游标定义使用
-- as --定义(游标一个可以遍历的结果集)   
-- cursor cur_1 is   
--   select area_code,cmcode,sum(rmb_amt)/10000 rmb_amt_sn,  
--          sum(usd_amt)/10000 usd_amt_sn   
--   from bgd_area_cm_m_base_t   
--   where ym >= vs_ym_sn_beg   
--        and ym <= vs_ym_sn_end   
--   group by area_code,cmcode;   
      
-- begin --执行（常用for语句遍历游标）       
-- for rec in cur_1 loop   
--   update xxxxxxxxxxx_t   
--    set rmb_amt_sn = rec.rmb_amt_sn,usd_amt_sn = rec.usd_amt_sn   
--    where area_code = rec.area_code   
--    and cmcode = rec.cmcode   
--    and ym = is_ym;   
-- end loop;


-- 游标的定义
--显示cursor的处理
-- declare  
-- ---声明cursor,创建和命名一个sql工作区
-- cursor cursor_name is  
--     select real_name from account_hcz;
--     v_realname varchar2(20);
-- begin 
--     open cursor_name;---打开cursor,执行sql语句产生的结果集
--     fetch cursor_name into v_realname;--提取cursor,提取结果集中的记录
--     dbms_output.put_line(v_realname);
--     close cursor_name;--关闭cursor
-- end;

-- 存储过程动态创建表，以时间给表命名
create or replace procedure create_table
as 
v_sql varchar2(2000);
begin
 v_sql:='create table ' || upper('tablename')||
 replace(to_char(sysdate,'yyyy-mm-dd'),'-','')|| 
 replace(to_char(sysdate,'hh24:mi:ss'),':','')||
  '(
  id number primary key,
  name varchar2(10),
  age number,
  sex char(2))';
  execute immediate v_sql;
  end;

 -- 执行下面的即可创建表
 call create_table();

create or replace procedure sp_sync_plan is 
  cursor c_emp is --声明显式游标  
    select * from dc_check_todo;  
  c_row c_emp%rowtype; --定义游标变量，该变量的类型为基于游标c_emp的记录  
begin 
  --for 循环  
  for c_row in c_emp loop  
    dbms_output.put_line(c_row.todo_id || '--' );  
  end loop;  
 
  --fetch 循环  
  open c_emp;--必须要明确的打开和关闭游标  
  loop  
    fetch c_emp  
      into c_row;  
    exit when c_emp%notfound;  
    dbms_output.put_line(c_row.todo_id || '++' );  
  end loop;  
  close c_emp;  
 
  --while 循环  
  open c_emp;--必须要明确的打开和关闭游标  
    fetch c_emp into c_row;  
    while c_emp%found loop  
      dbms_output.put_line(c_row.todo_id || '**' );  
      fetch c_emp into c_row;  
    end loop;  
  close c_emp;  
end sp_sync_plan;



-- 在oracle中对存储过程的调用
-- （1）过程调用方式一
-- declare  
--       realsal emp.sal%type;  
--       realname varchar(40);  
--       realjob varchar(40);  
-- begin   --过程调用开始  
--       realsal:=1100;  
--       realname:='';  
--       realjob:='clerk';  
--       runbyparmeters(realsal,realname,realjob);－－必须按顺序  
--       dbms_output.put_line(realname||'   '||realjob);  
-- end;  --过程调用结束 


-- （2）过程调用方式二
-- declare  
--      realsal emp.sal%type;  
--      realname varchar(40);  
--      realjob varchar(40);  
-- begin    --过程调用开始  
--      realsal:=1100;  
--      realname:='';  
--      realjob:='clerk';  
--      －－指定值对应变量顺序可变  
--      runbyparmeters(sname=>realname,isal=>realsal,sjob=>realjob);           
--     dbms_output.put_line(realname||'   '||realjob);  
-- end;  --过程调用结束 


-- （3）过程调用方式三（sql命令行方式下）
-- 1、sql>exec  proc_emp('参数1','参数2');--无返回值过程调用  
-- 2、sql>var vsal number  
--      sql> exec proc_emp ('参数1',:vsal);-- 有返回值过程调用  
--     或者：call proc_emp ('参数1',:vsal);-- 有返回值过程调用 



-- 存储过程案例
-- 限额控制
create or replace package body np_pckg_merchant_limit
as
  procedure check_limit (
      in_iplcode         in   varchar2,       --行业编号
      in_iplstate        in   varchar2,       --卡类型
      in_posno           in   varchar2,      --商户号
      in_tranamt         in   varchar2,      --交易金额
      out_retcode        out  varchar2      --返回码
  )
  is
    v_date             varchar2(8);     --系统日期
    v_merchanttype     varchar2(30);    --行业类型
    v_debitsinglemax   number(18,2);    --借记卡单笔限额
    v_debitdaymax      number(18,2);    --借记卡日累计限额
    v_debitmonthmax    number(18,2);    --借记卡月累计限额
    v_debityearmax     number(18,2);    --借记卡年累计限额
    v_debitdaysum      number(18,2);   --借记卡日累计限额当日发生额
    v_debitmonthsum    number(18,2);   --借记卡月累计限额当月发生额
    v_debityearsum     number(18,2);   --借记卡年累计限额当年发生额
    v_debitlastdate    number(18,2);   --借记卡限额上次交易日
    v_creditsinglemax  number(18,2);   --贷记卡单笔限额
    v_creditdaymax     number(18,2);   --贷记卡日累计限额
    v_creditmonthmax   number(18,2);   --贷记卡月累计限额
    v_credityearmax    number(18,2);   --贷记卡年累计限额
    v_creditdaysum     number(18,2);   --贷记卡日累计限额当日发生额
    v_creditmonthsum   number(18,2);   --贷记卡月累计限额当月发生额
    v_credityearsum    number(18,2);   --贷记卡年累计限额当年发生额
    v_creditlastdate   number(18,2);   --贷记卡限额上次交易日
    v_stt              varchar2(1);    --账户状态
  begin
    out_retcode := '0';

    --取当前日期
    v_date := to_char(sysdate, 'yyyymmdd');
    ----------------------------------------------------------------
    -- 判断商户收单限额(设置的客商户日累计限额)
    ----------------------------------------------------------------
    --取收单限额 也要区分借记卡 和 贷记卡

    if in_iplstate = 1 then --是借记卡
      begin
        select
            ipl_debit_single,ipl_debit_daymax,ipl_debit_monthmax,ipl_debit_yearmax
        into
            v_debitsinglemax,v_debitdaymax,v_debitmonthmax,v_debityearmax
        from
            im_pay_limit
        where
            ipl_code = in_iplcode and --此处需要一个参数，行业的code
            ipl_state in('00','01') ;  --先判断限额状态 00标示  如果是借记卡和贷记卡都可以用，或者借记卡和贷记卡只有一个能用，或者都不能用

        exception
            when no_data_found then
                null;
        dbms_output.put_line(v_debitsinglemax);
      end;
    elsif in_iplstate = 2 then --是贷记卡
      begin
        select
          ipl_credit_single,ipl_credit_daymax,ipl_credit_monthmax,ipl_credit_yearmax
        into
          v_creditsinglemax,v_creditdaymax,v_creditmonthmax,v_credityearmax
        from im_pay_limit
        where
          ipl_code = in_iplcode and --此处需要一个参数，行业的code
          ipl_state in('00','10');  --先判断限额状态 00标示  如果是借记卡和贷记卡都可以用，或者借记卡和贷记卡只有一个能用，或者都不能用

        exception
          when no_data_found then
            null;
      end;
    end if;


    --取商户年月日累计限额 ---
    begin
        select
            imd_debit_dayamt,
            imd_debit_monthamt,
            imd_debit_yearamt,
            imd_debit_transday,
            imd_credit_dayamt,
            imd_credit_monthamt,
            imd_credit_yearamt,
            imd_credit_transday
        into
            v_debitdaysum,
            v_debitmonthsum,
            v_debityearsum,
            v_debitlastdate,
            v_creditdaysum,
            v_creditmonthsum,
            v_credityearsum,
            v_creditlastdate
        from
            im_merchant_daysum
        where
            imd_posno = in_posno;

        exception
            when no_data_found then
                insert into im_merchant_daysum (imd_posno,imd_debit_dayamt,imd_debit_monthamt,imd_debit_yearamt,imd_credit_dayamt,imd_credit_monthamt,imd_credit_yearamt,imd_debit_transday,imd_credit_transday) values (in_posno,'0.00','0.00','0.00','0.00','0.00','0.00',v_date,v_date);
    end;
 
 
     --判断是商户借记卡 =1    还是贷记卡 =2  start
    if in_iplstate = 1 then
      --如果是借记卡，则判断借记卡的单笔，日累计，月累计，年累计限额  v_debitsinglemax
       if to_number(in_tranamt) > v_debitsinglemax then
          out_retcode := 'npml1001';                    --错误码npml1001:超过借记卡单笔限额
          --rollback;
          return;
       end if;
       -- 判断借记卡日累计交易限额否需要清零 ，如果是昨天的交易，今天需要清零 开始
          if v_date <> v_debitlastdate then --here
              v_debitdaysum := 0;
          end if;
       -- 判断借记卡日累计交易限额否需要清零 ，如果是昨天的交易，今天需要清零 结束
       if v_debitdaysum + to_number(in_tranamt) > v_debitdaymax then --借记卡日累计限额
          out_retcode := 'npml1002';                    --错误码npml1002:超过借记卡日累计限额
          --rollback;
          return;
       end if;
       --判断借记卡月累计交易限额是否需要清零，如果是上个月的交易，则临时置空 开始
          if substr(v_date,1,6) <> substr(v_debitlastdate,1,6) then
             v_debitmonthsum := 0;
          end if;
       --判断借记卡月累计交易限额是否需要清零，如果是上个月的交易，则临时置空 结束
       if v_debitmonthsum + to_number(in_tranamt) > v_debitmonthmax then --借记卡月累计限额
          out_retcode := 'npml1003';                    --错误码npml1003:超过借记卡月累计限额
          --rollback;
          return;
       end if;
       --判断借记卡年累计交易限额是否需要清零，如果是去年的交易，则临时置空 开始
          if substr(v_date,1,4) <> substr(v_debitlastdate,1,4) then
             v_debityearsum := 0;
          end if;
       --判断借记卡年累计交易限额是否需要清零，如果是去年的交易，则临时置空 结束
       if v_debityearsum + to_number(in_tranamt) > v_debityearmax then --借记卡年累计限额
          out_retcode := 'npml1004';                    --错误码npml1004:超过借记卡年累计限额
          --rollback;
          return;
       end if;
    elsif in_iplstate = 2 then
      --如果是贷记卡
      if to_number(in_tranamt) > v_creditsinglemax then
        out_retcode := 'npml1005';                    --错误码npml1005:超过贷记卡单笔限额
        --rollback;
        return;
      end if;
      -- 判断贷记卡日累计交易限额是否需要清零 开始
      if v_date <> v_creditlastdate then --here
          v_creditdaysum := 0;
      end if;
      -- 判断贷记卡日累计交易限额是否需要清零 结束
      if v_creditdaysum + to_number(in_tranamt) > v_creditdaymax then --贷记卡日累计限额
        out_retcode := 'npml1006';                    --错误码npml1006:超过贷记卡日累计限额
        --rollback;
        return;
      end if;
      --判断贷记卡月累计交易限额是否需要清零，如果是上个月的交易，则临时置空 开始
      if substr(v_date,1,6) <> substr(v_creditlastdate,1,6) then
        v_creditmonthsum := 0;
      end if;
      --判断贷记卡月累计交易限额是否需要清零，如果是上个月的交易，则临时置空 结束
      if v_creditmonthsum + to_number(in_tranamt) > v_creditmonthmax then --贷记卡月累计限额
        out_retcode := 'npml1007';                    --错误码npml1007:超过贷记卡月累计限额
        --rollback;
        return;
      end if;
      --判断贷记卡年累计交易限额是否需要清零，如果是去年的交易，则临时置空 开始
      if substr(v_date,1,4) <> substr(v_creditlastdate,1,4) then
        v_credityearsum := 0;
      end if;
      --判断贷记卡年累计交易限额是否需要清零，如果是去年的交易，则临时置空 结束
      if v_credityearsum + to_number(in_tranamt) > v_credityearmax then --贷记卡月累计限额
        out_retcode := 'npml1008';                    --错误码npml1008:超过贷记卡年累计限额
        --rollback;
        return;
      end if;
    end if;
    --判断是商户借记卡 =1    还是贷记卡 =2  end
    commit;
  end;


  procedure update_limit (
      in_posno               in    varchar2,            --商户号
      in_iplstate            in    varchar2,            --卡类型
      in_tranamt             in    varchar2,            --交易金额
      out_retcode            out   varchar2            --返回码
  )
  is
    v_date             varchar2(8);      --系统日期
    v_debitdaysum      number(18,2);   --借记卡日累计限额当日发生额
    v_debitmonthsum    number(18,2);   --借记卡月累计限额当月发生额
    v_debityearsum     number(18,2);   --借记卡年累计限额当年发生额
    v_debitlastdate    number(18,2);   --借记卡限额上次交易日

    v_creditdaysum     number(18,2);   --贷记卡日累计限额当日发生额
    v_creditmonthsum   number(18,2);   --贷记卡月累计限额当月发生额
    v_credityearsum    number(18,2);   --贷记卡年累计限额当年发生额
    v_creditlastdate   number(18,2);   --贷记卡限额上次交易日

  begin
    out_retcode := '0';

    --取当前日期
    v_date := to_char(sysdate, 'yyyymmdd');

    --取客户日累计限额
    begin
      select
        imd_debit_dayamt,
        imd_debit_monthamt,
        imd_debit_yearamt,
        imd_credit_dayamt,
        imd_credit_monthamt,
        imd_credit_yearamt
      into
        v_debitdaysum,
        v_debitmonthsum,
        v_debityearsum,
        v_creditdaysum,
        v_creditmonthsum,
        v_credityearsum
      from im_merchant_daysum
      where imd_posno = in_posno
      for update;

      exception
        when no_data_found then
             null;
    end;
    --判断借记卡日累计交易限额否需要清零
    if v_date <> v_debitlastdate then
         v_debitdaysum := 0;
    end if;
     -- 判断贷记卡日累计交易限额是否需要清零
    if v_date <> v_creditlastdate then --here
        v_creditdaysum := 0;
    end if;
    --判断借记卡月累计交易限额否需要清零
    if substr(v_date,1,6) <> substr(v_debitlastdate,1,6) then
        v_debitmonthsum := 0;
    end if;
    --判断贷记卡月累计交易限额否需要清零
    if substr(v_date,1,6) <> substr(v_creditlastdate,1,6) then
        v_creditmonthsum := 0;
    end if;
    --判断借记卡年累计交易限额否需要清零
    if substr(v_date,1,4) <> substr(v_debitlastdate,1,4) then
        v_debityearsum := 0;
    end if;
    --判断贷记卡年累计交易限额否需要清零
    if substr(v_date,1,4) <> substr(v_creditlastdate,1,4) then
        v_credityearsum := 0;
    end if;
    --更新商户收单限额累计表    需要区分借记卡和贷记卡
    if in_iplstate = 1 then --借记卡
      update im_merchant_daysum --更新借记卡收单累计限额
      set
           imd_debit_dayamt = v_debitdaysum + to_number(in_tranamt),
           imd_debit_monthamt = v_debitmonthsum + to_number(in_tranamt),
           imd_debit_yearamt = v_debityearsum + to_number(in_tranamt),
           imd_debit_transday = v_date
      where
          imd_posno = in_posno;

      commit;
    elsif in_iplstate = 2 then --贷记卡
      update im_merchant_daysum --更新贷记卡收单累计限额
        set
             imd_credit_dayamt = v_creditdaysum + to_number(in_tranamt),
             imd_credit_monthamt = v_creditmonthsum + to_number(in_tranamt),
             imd_credit_yearamt = v_credityearsum + to_number(in_tranamt),
             imd_credit_transday = v_date
        where
            imd_posno = in_posno;

        commit;
    end if;
  end;

  procedure roll_limit (
    in_posno        in  varchar2,     --商户号
    in_iplstate           in varchar2,        --卡类型
    in_orderno        in  varchar2,     --交易流水号
    out_retcode       out varchar2      --存储过程返回码
  )
  is
    v_amt     varchar2(20);
    v_transdate varchar2(8);
    v_nowdate   varchar2(8);
  begin
    out_retcode:='0';
    v_nowdate:=to_char(sysdate, 'yyyymmdd');

    --打开cursor户日累计限额
    begin
      select
        substr(npf_tran_time,1,8),
        npf_order_amt
      into
        v_transdate,
        v_amt
      from np_pay_flow
      where npf_flowno = in_orderno
      for update;

      exception
        when no_data_found then
            null;
    end;

    if v_transdate ='' then
      out_retcode:='0';
      return;
    end if;

    --if v_transdate<> v_nowdate then--如果不是今天的指令，不处理当日的限额
    --  out_retcode:='0';
    --  return;
    --end if;
    --查找到该订单，并且回滚的是今天的订单
    --如果是借记卡交易

    if in_iplstate = 1 then --回滚借记卡
      if v_transdate = v_nowdate then--如果交易日期小于今天当天日期，则判断是否为本月的交易，    回滚当月和当年的
        update im_merchant_daysum--更新当天、本月、本年的累计额度
        set
          imd_debit_dayamt = imd_debit_dayamt - v_amt,--更新当日的限额
          imd_debit_monthamt = imd_debit_monthamt - v_amt,--更新本月的限额
          imd_debit_yearamt = imd_debit_yearamt - v_amt--更新本年的限额
        where
          imd_posno = in_posno;--商户号
      commit;
      elsif v_transdate < v_nowdate then --如果交易时间不是今天，则判断是否为本月的交易
        if substr(v_transdate,1,6) = substr(v_nowdate,1,6) then--不是当天的交易，则判断是否为本月的交易start
          update im_merchant_daysum--更新本月、本年的交易
          set
            imd_debit_monthamt = imd_debit_monthamt - v_amt,--更新本月的限额
            imd_debit_yearamt = imd_debit_yearamt - v_amt --更新本年的限额
          where
            imd_posno = in_posno;--商户号
        commit;
        elsif substr(v_transdate,1,6) < substr(v_nowdate,1,6) then--不是当天的交易，也不是本月的交易，则判断是否为本年的交易
          if substr(v_transdate,1,4) = substr(v_nowdate,1,4) then--不是当天的交易，也不是本月的交易，是本年的交易
            update im_merchant_daysum--更新本年的交易
              set
                imd_debit_yearamt = imd_debit_yearamt - v_amt--更新本年的限额
              where
                imd_posno = in_posno;--商户号
            commit;
          end if;
        end if;--不是当天的交易，则判断是否为本月的交易end
      end if;--回滚借记卡结束
    elsif in_iplstate = 2 then  --回滚贷记卡
      if v_transdate = v_nowdate then--如果交易日期小于今天当天日期，则判断是否为本月的交易，    回滚当月和当年的
        update im_merchant_daysum--更新当天、本月、本年的累计额度
        set
          imd_credit_dayamt = imd_credit_dayamt - v_amt,--更新当日的限额
          imd_credit_monthamt = imd_credit_dayamt - v_amt,--更新本月的限额
          imd_credit_yearamt = imd_credit_yearamt - v_amt--更新本年的限额
        where
          imd_posno = in_posno;--商户号
        commit;
      elsif v_transdate < v_nowdate then --如果交易时间不是今天，则判断是否为本月的交易
        if substr(v_transdate,1,6) = substr(v_nowdate,1,6) then--不是当天的交易，则判断是否为本月的交易start
          update im_merchant_daysum--更新本月、本年的交易
          set
            imd_credit_monthamt = imd_credit_monthamt - v_amt,--更新本月的限额
            imd_credit_yearamt = imd_credit_yearamt - v_amt--更新本年的限额
          where
            imd_posno = in_posno;--商户号
        commit;
        elsif substr(v_transdate,1,6) < substr(v_nowdate,1,6) then--不是当天的交易，也不是本月的交易，则判断是否为本年的交易
          if substr(v_transdate,1,4) = substr(v_nowdate,1,4) then--不是当天的交易，也不是本月的交易，是本年的交易
            update im_merchant_daysum--更新本年的交易
              set
                imd_credit_yearamt = imd_credit_yearamt - v_amt --更新本年的限额
              where
                imd_posno = in_posno;--商户号
            commit;
          end if;
        end if;--不是当天的交易，则判断是否为本月的交易end
      end if;--回滚借记卡结束
    end if;--回滚借记卡、贷记卡结束
  end;

end np_pckg_merchant_limit;



create or replace procedure update_students
as 
begin
   update students set student_age=10;
   commit;
end update_students;


create or replace procedure update_students(in_age in number, out_age out number) 
as
begin
  update students set student_age=in_age;
  select student_age into out_age from students where student_id=1;
  commit;
end update_students;
   
   
create or replace procedure swap(in_out_param1 in out number, in_out_param2 in out number)
as 
begin
  declare param number;
  begin
    param:=in_out_param1;
    in_out_param1 := in_out_param2;
    in_out_param2 := param;
  end;
end;


create or replace procedure insert_objects 
as
begin
  declare
  cursor cu_objects is select * from user_objects order by object_id;
  obj user_objects%rowtype;
  previous_name user_objects.object_name%type;
  begin
    open cu_objects;
    fetch cu_objects into obj;
    while cu_objects%found loop
      insert into target
      values
      (
        obj.object_id,
        obj.object_name,
        obj.object_type,
        previous_name,
        obj.status
      );
      previous_name := obj.object_name;
      fetch cu_objects into obj;
    end loop;
  end;
end insert_objects;


create or replace procedure proc_query_purchaseorder
as
begin
    --语句
    drop table purchaseorder_view_table purge;
    create table purchaseorder_view_table as 
    (
      select * from 
      (
        purchaseorder_view
      ) 
      where rest_qty>0  and 
      (upper(supplier) like '%wencor west inc%' or upper(supplier) like '%wen%')
    );
    commit;
end;


-- 创建用户表并且插入用户数据的存储过程
create or replace procedure proc_add_user
(
    user_id         varchar2,   --操作用户名工号
    user_name       varchar2,   --用户名
    en_name         varchar2,   --英文名称
    password        varchar2,   --密码
    tel             varchar2,   --电话 
    fax             varchar2,   --传真 
    position        varchar,    --职务
    en_position     varchar,    --职务英文名 
    addr            varchar2,   --用户联系地址
    sex             varchar2,   --性别
    birthday        varchar2,   --出生年月
    degree          varchar2,   --教育水平学位
    join_date       varchar2,   --进入公司时间
    dept_name       varchar2,   --所属部门
    dept_en_name    varchar2,   --部门英文名称
    group_id        varchar2,   --属于的组号
    author_code     varchar2,   --授权码
    operation_right varchar2,   --操作权限
    right_dept      varchar2,   --可查看的部门
    search_right    varchar2    --查看权限
)
as
begin
     insert into users(user_id, user_name,en_name,password,user_tel,user_fax,position,user_en_pstn,
     user_addr,sex,birth,degree,join_date,dept_name,dept_en_name,group_id,author_code,operation_right,
     right_dept,search_right) 
     values(user_id,user_name,en_name,password,tel,fax,position,en_position,addr,
     sex,birthday,degree,join_date,dept_name,dept_en_name,group_id,author_code,
     operation_right,right_dept,search_right);
     commit;
end;


--创建一个pl/sql存储过程disp_dept_summary
--在触发器中调用该过程显示dept_summary标中的数据。
create or replace procedure disp_dept_summary
is
  rec dept_summary%rowtype;
  cursor c1 is select * from dept_summary;
begin
  open c1;
  fetch c1 into rec;
  dbms_output.put_line('deptno    sal_sum    emp_count');
  dbms_output.put_line('-------------------------------------');
  while c1%found loop
    dbms_output.put_line(rpad(rec.deptno, 6)||
      to_char(rec.sal_sum, '$999,999.99')||
      lpad(rec.emp_count, 13));
    fetch c1 into rec;
  end loop;
  close c1;
end;
begin
  dbms_output.put_line('插入前');
  disp_dept_summary();
  dbms_utility.exec_ddl_statement('
    create or replace trigger trig1
      after insert or delete or update of sal on emp
    begin
      dbms_output.put_line(''正在执行trig1 触发器…'');
      delete from dept_summary;
      insert into dept_summary(deptno, sal_sum, emp_count)
      select deptno, sum(sal), count(*) 
      from emp group by deptno;
    end;
  ');


  insert into dept(deptno, dname, loc) 
  values(90, 'demo_dept', 'none_loc');

  insert into emp(ename, deptno, empno, sal)
  values(user, 90, 9999, 3000);

  dbms_output.put_line('插入后');
  disp_dept_summary();

  update emp set sal=1000 where empno=9999;
  dbms_output.put_line('修改后');
  disp_dept_summary();

  delete from emp where empno=9999;
  delete from dept where deptno=90;

  dbms_output.put_line('删除后');
  disp_dept_summary(); 
  dbms_utility.exec_ddl_statement('drop trigger trig1');
exception
   when others then
      dbms_output.put_line(sqlcode||'---'||sqlerrm);

end;




create or replace procedure bulk_insert(in_bulk_count integer)
is
cursor cur is select * from b;
type tbl_b is table of b%rowtype index by pls_integer;
v_tbl_b tbl_b;
begin
  open cur;
  loop
  <<bulk_insert>>
  exit when cur%notfound;
  fetch cur bulk collect into v_tbl_b limit in_bulk_count;
  forall i in indices of v_tbl_b save exceptions
    insert /*+append*/ into a values v_tbl_b(i);
    commit;
  exception
    when others then 
      null;
  end loop bulk_insert;
  close cur;
end;




-- 15.创建同义词
-- 1、不占内存空间，节省大量的数据库空间
-- 2、简化了数据库对象的访问
-- 3、提高了数据库对象访问的安全性
-- 4、扩展的数据库的使用范围，能够在不同的数据库用户之间实现无缝交互;
-- 同义词可以创建在不同一个数据库服务器上，通过网络实现连接
-- create the synonym 
create or replace synonym syn_base_user
  for hccpms.base_user@cpms.dblink;

  -- create the synonym 
create or replace synonym syn_xods_bosdb_item
  for hccpms.dsj_xods_bosdb_item@wmgorcl.dblink;

create public synonym table_a for  user.table_a;

-- 删除同义词
drop public synonym syn_base_user;


-- 16.查询数据库和客户端字符集
--查询服务器字符集
select userenv('language') from dual

select * from v$nls_parameters

select * from v$nls_parameters t where t.parameter ='nls_language' or t.parameter ='nls_characterset';

select * from nls_database_parameters where parameter like '%characterset%'

select * from nls_database_parameters where parameter = 'nls_characterset'

--客户端字符集环境
select * from nls_instance_parameters where parameter = 'nls_language'

select * from nls_session_parameters;


select property_value from database_properties where property_name = 'nls_characterset';


-- 修改数据库字符集
alter database character set internal_convert zhs16gbk;

-- 修改国家字符集
alter database national character set internal_convert al16utf16;


-- 17.创建序列
-- 1.首先创建序列，oracle序列的语法格式为：
-- create sequence 序列名
-- [increment by n]
-- [start with n]
-- [{maxvalue/ minvalue n|nomaxvalue}]
-- [{cycle|nocycle}]
-- [{cache n|nocache}];

-- 1)increment by用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表oracle序列的值是按照此步长递减的。
-- 2)start with 定义序列的初始值(即产生的第一个值)，默认为1。
-- 3)maxvalue 定义序列生成器能产生的最大值。选项nomaxvalue是默认选项，代表没有最大值定义，这时对于递增oracle序列，
-- 系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。
-- 4)minvalue定义序列生成器能产生的最小值。选项nomaxvalue是默认选项，代表没有最小值定义，这时对于递减序列，
-- 系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。
-- 5)cycle和nocycle 表示当序列生成器的值达到限制值后是否循环。cycle代表循环，nocycle代表不循环。如果循环，
-- 则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。
-- 6)cache(缓冲)定义存放序列的内存块的大小，默认为20。nocache表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。

-- 2.删除oracle序列的语法是drop sequence 序列名;

--假设有表test，其主键为test_id
--1)建立递增序列seq_test:
create sequence seq_test
minvalue 1 
nomaxvalue
start with 1
increment by 1
nocycle

--2)建立触发器，当有数据插入表test时，使用oracle序列为其去的递增的主键值
create trigger trg_test before insert on test
for each row
begin
select seq_test.nextval into :new.test_id from dual;
end;



create sequence seq_rmp_microscope_list_id
minvalue 1
maxvalue 9999999999
start with 1
increment by 1
nocache
order;


-- create sequence 修改序列seq_rmp_user_info_id
create sequence seq_rmp_user_info_id
minvalue 1
maxvalue 9999999999
start with 181
increment by 1
cache 20;




-- 18.查询序列编号
select seq_rmp_check_type_id.nextval from dual

select seq_rmp_check_type_id.currval from dual

select seq_rmp_doctors_id.nextval from dual

select seq_rmp_doctors_id.currval from dual


--当然也可以不使用触发器，而是在插入时在sql语句中调用序列，例如
insert into test values(seq_test.nextval, ……)


-- 19.创建或修改触发器
-- 8.1 触发器类型
-- 8.1.1 dml触发器
-- 8.1.2 替代触发器
-- 8.1.3 系统触发器
-- 8.2 创建触发器
-- 8.2.1 触发器触发次序
-- 8.2.2 创建dml触发器
-- 8.2.3 创建替代(instead of)触发器
-- 8.2.3 创建系统事件触发器
-- 8.2.4 系统触发器事件属性
-- 8.2.5 使用触发器谓词
-- 8.2.6 重新编译触发器
-- 8.3 删除和使能触发器
-- 8.4 触发器和数据字典
-- 8.5   数据库触发器的应用举例
/*
触发器是许多关系数据库系统都提供的一项技术。在oracle系统里，触发器类似过程和函数，都有声明，执行和异常处理过程的pl/sql块。
8.1 触发器类型
    触发器在数据库里以独立的对象存储，它与存储过程和函数不同的是，存储过程与函数需要用户显示调用才执行，
    而触发器是由一个事件来启动运行。即触发器是当某个事件发生时自动地隐式运行。并且，触发器不能接收参数。
    所以运行触发器就叫触发或点火（firing）。oracle事件指的是对数据库的表进行的insert、update及delete操作或对视图进行类似的操作。
    oracle将触发器的功能扩展到了触发oracle，如数据库的启动与关闭等。所以触发器常用来完成由数据库的完整性约束难以完成的
    复杂业务规则的约束，或用来监视对数据库的各种操作，实现审计的功能。
 
8.1.1 dml触发器
    oracle可以在dml语句进行触发，可以在dml操作前或操作后进行触发，并且可以对每个行或语句操作上进行触发。
 
8.1.2 替代触发器
    由于在oracle里，不能直接对由两个以上的表建立的视图进行操作。所以给出了替代触发器。它就是oracle 8专门为进行视图操作的一种处理方法。
 
8.1.3 系统触发器
oracle 8i 提供了第三种类型的触发器叫系统触发器。它可以在oracle数据库系统的事件中进行触发，如oracle系统的启动与关闭等。
 
触发器组成: 
l         触发事件：引起触发器被触发的事件。 例如：dml语句(insert, update, delete语句对表或视图执行数据处理操作)、
ddl语句（如create、alter、drop语句在数据库中创建、修改、删除模式对象）、数据库系统事件（如系统启动或退出、异常错误）、
用户事件（如登录或退出数据库）。
l         触发时间：即该trigger 是在触发事件发生之前（before）还是之后(after)触发，也就是触发事件和该trigger 的操作顺序。
l         触发操作：即该trigger 被触发之后的目的和意图，正是触发器本身要做的事情。 例如：pl/sql 块。
l         触发对象：包括表、视图、模式、数据库。只有在这些对象上发生了符合触发条件的触发事件，才会执行触发操作。
l         触发条件：由when子句指定一个逻辑表达式。只有当该表达式的值为true时，遇到触发事件才会自动执行触发器，使其执行触发操作。
l         触发频率：说明触发器内定义的动作被执行的次数。即语句级(statement)触发器和行级(row)触发器。
语句级(statement)触发器：是指当某触发事件发生时，该触发器只执行一次；
行级(row)触发器：是指当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次。
编写触发器时，需要注意以下几点：
l         触发器不接受参数。
l         一个表上最多可有12个触发器，但同一时间、同一事件、同一类型的触发器只能有一个。并各触发器之间不能有矛盾。
l         在一个表上的触发器越多，对在该表上的dml操作的性能影响就越大。
l        触发器最大为32kb。若确实需要，可以先建立过程，然后在触发器中用call语句进行调用。
l         在触发器的执行部分只能用dml语句（select、insert、update、delete），不能使用ddl语句（create、alter、drop）。
l         触发器中不能包含事务控制语句(commit，rollback，savepoint)。因为触发器是触发语句的一部分，触发语句被提交、回退时，
触发器也被提交、回退了。
l         在触发器主体中调用的任何过程、函数，都不能使用事务控制语句。
l         在触发器主体中不能申明任何long和blob变量。新值new和旧值old也不能是表中的任何long和blob列。
l         不同类型的触发器(如dml触发器、instead of触发器、系统触发器)的语法格式和作用有较大区别。
 
8.2 创建触发器
创建触发器的一般语法是:
 
create [or replace] trigger trigger_name
{before | after }
{insert | delete | update [of column [, column …]]}
[or {insert | delete | update [of column [, column …]]}...]
on [schema.]table_name | [schema.]view_name 
[referencing {old [as] old | new [as] new| parent as parent}]
[for each row ]
[when condition]
pl/sql_block | call procedure_name;
 
 
其中：
before 和after指出触发器的触发时序分别为前触发和后触发方式，前触发是在执行触发事件之前触发当前所创建的触发器，
后触发是在执行触发事件之后触发当前所创建的触发器。
       for each row选项说明触发器为行触发器。行触发器和语句触发器的区别表现在：行触发器要求当一个dml语句操作影响数据库中的多行数据时，
       对于其中的每个数据行，只要它们符合触发约束条件，均激活一次触发器；而语句触发器将整个语句操作作为触发事件，
       当它符合约束条件时，激活一次触发器。当省略for each row 选项时，before 和after 触发器为语句触发器，而instead of 
       触发器则只能为行触发器。
           referencing 子句说明相关名称，在行触发器的pl/sql块和when 子句中可以使用相关名称参照当前的新、旧列值，
           默认的相关名称分别为old和new。触发器的pl/sql块中应用相关名称时，必须在它们之前加冒号(:)，但在when子句中则不能加冒号。
when 子句说明触发约束条件。condition 为一个逻辑表达时，其中必须包含相关名称，而不能包含查询语句，也不能调用pl/sql 函数。
when 子句指定的触发约束条件只能用在before 和after 行触发器中，不能用在instead of 行触发器和其它类型的触发器中。
    当一个基表被修改( insert, update, delete)时要执行的存储过程，执行时根据其所依附的基表改动而自动触发，
    因此与应用程序无关，用数据库触发器可以保证数据的一致性和完整性。
 
每张表最多可建立12 种类型的触发器，它们是:
before insert
before insert for each row
after insert
after insert for each row
 
before update
before update for each row
after update
after update for each row
 
before delete
before delete for each row
after delete
after delete for each row
 
8.2.1 触发器触发次序
1.       执行 before语句级触发器;
2.       对与受语句影响的每一行：
l         执行 before行级触发器
l         执行 dml语句
l         执行 after行级触发器 
3.       执行 after语句级触发器
 
8.2.2 创建dml触发器
    触发器名与过程名和包的名字不一样，它是单独的名字空间，因而触发器名可以和表或过程有相同的名字，但在一个模式中触发器名不能相同。
 
dml触发器的限制
l         create trigger语句文本的字符长度不能超过32kb；
l         触发器体内的select 语句只能为select … into …结构，或者为定义游标所使用的select 语句。
l         触发器中不能使用数据库事务控制语句 commit; rollback, svaepoint 语句；
l         由触发器所调用的过程或函数也不能使用数据库事务控制语句；
l         触发器中不能使用long, long raw 类型；
l         触发器内可以参照lob 类型列的列值，但不能通过 :new 修改lob列中的数据；
 
dml触发器基本要点
l         触发时机：指定触发器的触发时间。如果指定为before，则表示在执行dml操作之前触发，以便防止某些错误操作发生或
实现某些业务规则；如果指定为after，则表示在执行dml操作之后触发，以便记录该操作或做某些事后处理。
l         触发事件：引起触发器被触发的事件，即dml操作（insert、update、delete）。既可以是单个触发事件，也可以是多个触发
事件的组合（只能使用or逻辑组合，不能使用and逻辑组合）。
l         条件谓词：当在触发器中包含多个触发事件（insert、update、delete）的组合时，为了分别针对不同的事件进行不同的处理，
需要使用oracle提供的如下条件谓词。
1）。inserting：当触发事件是insert时，取值为true，否则为false。
2）。updating [（column_1,column_2,…,column_x）]：当触发事件是update      时，如果修改了column_x列，则取值为true，
否则为false。其中column_x是可选的。
3）。deleting：当触发事件是delete时，则取值为true，否则为false。
解发对象：指定触发器是创建在哪个表、视图上。
l         触发类型：是语句级还是行级触发器。
l         触发条件：由when子句指定一个逻辑表达式，只允许在行级触发器上指定触发条件，指定updating后面的列的列表。
 
问题：当触发器被触发时，要使用被插入、更新或删除的记录中的列值，有时要使用操作前、        后列的值.
实现:  :new 修饰符访问操作完成后列的值
       :old 修饰符访问操作完成前列的值
 
特性
insert
update
delete
old
null
实际值
实际值
new
实际值
实际值
null
*/


--创建触发器的一般语法是:
create [or replace] trigger trigger_name
instead of
{insert | delete | update [of column [, column …]]}
[or {insert | delete | update [of column [, column …]]}...]
on [schema.] view_name --只能定义在视图上
[referencing {old [as] old | new [as] new| parent as parent}]
[for each row ] --因为instead of触发器只能在行级上触发,所以没有必要指定
[when condition]
pl/sql_block | call procedure_name;


create trigger trg_test 
before insert on test
for each row
begin
  select seq_test.nextval into :new.test_id from dual;
end;


-- 修改触发器trig_rmp_user_info_id
create or replace trigger trig_rmp_user_info_id
before insert on rmp_user_info  
for each row
begin
   select  seq_rmp_user_info_id.nextval into :new.user_id  from dual;
end;


-- 我们可以创建instead_of触发器来为 delete 操作执行所需的处理，即删除emp表中所有基准行： 
create or replace trigger emp_view_delete
   instead of delete on emp_view for each row
begin
   delete from emp where deptno= :old.deptno;
end emp_view_delete; 


drop trigger emp_view_delete;


--例2：创建复杂视图，针对insert操作创建instead of触发器，向复杂视图插入数据。
--l         创建视图：
 
create or replace force view "hr"."v_reg_cou" ("r_id", "r_name", "c_id", "c_name")
as
 select r.region_id,
    r.region_name,
    c.country_id,
    c.country_name
 from regions r,
    countries c
 where r.region_id = c.region_id;
 
--l        创建触发器：
 
create or replace trigger "hr.tr_i_o_reg_cou" instead of
 insert on v_reg_cou for each row declare v_count number;
begin
  select count(*) into v_count from regions where region_id = :new.r_id;
  if v_count = 0 then
    insert into regions
      (region_id, region_name
      ) values
      (:new.r_id, :new.r_name
      );
  end if;

  select count(*) into v_count from countries where country_id = :new.c_id;
  if v_count = 0 then
    insert into countries
      (
        country_id,
        country_name,
        region_id
      )
      values
      (
        :new.c_id,
        :new.c_name,
        :new.r_id
      );
  end if;
end;





/*
例1: 建立一个触发器, 当职工表 emp 表被删除一条记录时，把被删除记录写到职工表删除日志表中去。
*/ 
create table emp_his as select * from emp where 1=2; 
create or replace trigger tr_del_emp 
   before delete --指定触发时机为删除操作前触发
   on scott.emp 
   for each row   --说明创建的是行级触发器 
begin
   --将修改前数据插入到日志记录表 del_emp ,以供监督使用。
   insert into emp_his(deptno , empno, ename , job ,mgr , sal , comm , hiredate )
       values( :old.deptno, :old.empno, :old.ename , :old.job,:old.mgr, :old.sal, :old.comm, :old.hiredate );
end;
delete emp where empno=7788;
drop table emp_his;
drop trigger del_emp;

/*
例2：限制对departments表修改（包括insert,delete,update）的时间范围，即不允许在非工作时间修改departments表。
*/
create or replace trigger tr_dept_time
before insert or delete or update 
on departments
begin
 if (to_char(sysdate,'day') in ('星期六', '星期日')) or (to_char(sysdate, 'hh24:mi') not between '08:30' and '18:00') then
     raise_application_error(-20001, '不是上班时间，不能修改departments表');
 end if;
end;

/*
例3：限定只对部门号为80的记录进行行触发器操作。
*/
create or replace trigger tr_emp_sal_comm
before update of salary, commission_pct
       or delete
on hr.employees
for each row
when (old.department_id = 80)
begin
 case
     when updating ('salary') then
        if :new.salary < :old.salary then

           raise_application_error(-20001, '部门80的人员的工资不能降');
        end if;
     when updating ('commission_pct') then

        if :new.commission_pct < :old.commission_pct then



 

/* 
创建instead of触发器需要注意以下几点：
l         只能被创建在视图上，并且该视图没有指定with check option选项。
l         不能指定before 或 after选项。
l         for each row子可是可选的，即instead of触发器只能在行级上触发、或只能是行级触发器，没有必要指定。
l         没有必要在针对一个表的视图上创建instead of触发器，只要创建dml触发器就可以了。
 
8.2.3 创建系统事件触发器
    oracle10g提供的系统事件触发器可以在ddl或数据库系统上被触发。ddl指的是数据定义语言，如create 、alter及drop 等。
    而数据库系统事件包括数据库服务器的启动或关闭，用户的登录与退出、数据库服务错误等。创建系统触发器的语法如下： 
创建触发器的一般语法是:
 
create or replace trigger [sachema.]trigger_name
{before|after} 
{ddl_event_list | database_event_list}
on { database | [schema.]schema }
[when condition]
pl/sql_block | call procedure_name;
 
其中: ddl_event_list：一个或多个ddl 事件，事件间用 or 分开；
        database_event_list：一个或多个数据库事件，事件间用 or 分开；
 
           系统事件触发器既可以建立在一个模式上，又可以建立在整个数据库上。当建立在模式(schema)之上时，只有模式所指定
           用户的ddl操作和它们所导致的错误才激活触发器, 默认时为当前用户模式。当建立在数据库(database)之上时，
           该数据库所有用户的ddl操作和他们所导致的错误，以及数据库的启动和关闭均可激活触发器。要在数据库之上建立触发器时，
           要求用户具有administer database trigger权限。
 
下面给出系统触发器的种类和事件出现的时机（前或后）：
事件
允许的时机
说明
startup
after
启动数据库实例之后触发
shutdown
before
关闭数据库实例之前触发（非正常关闭不触发）
servererror
after
数据库服务器发生错误之后触发
logon
after
成功登录连接到数据库后触发
logoff
before
开始断开数据库连接之前触发
create
before，after
在执行create语句创建数据库对象之前、之后触发
drop
before，after
在执行drop语句删除数据库对象之前、之后触发
alter
before，after
在执行alter语句更新数据库对象之前、之后触发
ddl
before，after
在执行大多数ddl语句之前、之后触发
grant
before，after
执行grant语句授予权限之前、之后触发
revoke
before，after
执行revoke语句收权限之前、之后触犯发
rename
before，after
执行rename语句更改数据库对象名称之前、之后触犯发
audit / noaudit
before，after
执行audit或noaudit进行审计或停止审计之前、之后触发
 
 
8.2.4 系统触发器事件属性
 
事件属性\事件
startup/shutdown
servererror
logon/logoff
ddl
dml
事件名称
ü＊
ü＊
ü＊
ü＊
＊
数据库名称
ü＊ 
数据库实例号
ü＊
错误号 
ü＊
用户名 
ü＊
模式对象类型
ü＊
模式对象名称
ü＊
列
ü＊
 
除dml语句的列属性外，其余事件属性值可通过调用oracle定义的事件属性函数来读取。
函数名称
数据类型
说    明
ora_sysevent
varchar2（20）
激活触发器的事件名称
instance_num
number
数据库实例名
ora_database_name
varchar2（50）
数据库名称
server_error(posi)
number
错误信息栈中posi指定位置中的错误号
 
 
is_servererror(err_number)
 
 
boolean
检查err_number指定的错误号是否在错误信息栈中，如果在则返回true，否则返回false。在触发器内调用此函数可以判断是否发生指定的错误。
login_user
varchar2(30)
登陆或注销的用户名称
dictionary_obj_type
varchar2(20)
ddl语句所操作的数据库对象类型
dictionary_obj_name
varchar2(30)
ddl语句所操作的数据库对象名称
dictionary_obj_owner
varchar2(30)
ddl语句所操作的数据库对象所有者名称
des_encrypted_password
varchar2(2)
正在创建或修改的经过des算法加密的用户口令
 */
--例1：创建触发器，存放有关事件信息。
desc ora_sysevent
desc ora_login_user

--创建用于记录事件用的表

create table ddl_event
(crt_date timestamp primary key,
 event_name varchar2(20), 
 user_name varchar2(10),
 obj_type varchar2(20),
 obj_name varchar2(20));

--创建触发器
create or replace trigger tr_ddl
after ddl on schema
begin
   insert into ddl_event values
   (systimestamp,ora_sysevent, ora_login_user, 
    ora_dict_obj_type, ora_dict_obj_name);
end tr_ddl;
 

--例2：创建登录、退出触发器。 
create table log_event
(user_name varchar2(10),
 address varchar2(20), 
 logon_date timestamp,
 logoff_date timestamp); 

--创建登录触发器
create or replace trigger tr_logon
after logon on database
begin
   insert into log_event (user_name, address, logon_date)
   values (ora_login_user, ora_client_ip_address, systimestamp);
end tr_logon;

--创建退出触发器
create or replace trigger tr_logoff
before logoff on database
begin
   insert into log_event (user_name, address, logoff_date)
   values (ora_login_user, ora_client_ip_address, systimestamp);
end tr_logoff;

/*
8.2.5 使用触发器谓词
    oracle 提供三个参数inserting, updating,deleting 用于判断触发了哪些操作。
谓词
行为
inserting
如果触发语句是 insert 语句，则为true,否则为false
updating
如果触发语句是 update语句，则为true,否则为false
deleting
如果触发语句是 delete 语句，则为true,否则为false
 
8.2.6 重新编译触发器
如果在触发器内调用其它函数或过程，当这些函数或过程被删除或修改后，触发器的状态将被标识为无效。当dml语句激活一个无效触发器时，
oracle将重新编译触发器代码，如果编译时发现错误，这将导致dml语句执行失败。
在pl/sql程序中可以调用alter trigger语句重新编译已经创建的触发器，格式为：           
alter trigger [schema.] trigger_name compile [ debug]
       其中：debug 选项要器编译器生成pl/sql 程序条使其所使用的调试代码。
8.3 删除和使能触发器
l         删除触发器：
drop trigger trigger_name;
当删除其他用户模式中的触发器名称，需要具有drop any trigger系统权限，当删除建立在数据库上的触发器时，用户需要
具有administer database trigger系统权限。
此外，当删除表或视图时，建立在这些对象上的触发器也随之删除。 
l         禁用或启用触发器
数据库trigger 的状态：
有效状态(enable)：当触发事件发生时，处于有效状态的数据库触发器trigger 将被触发。
无效状态(disable)：当触发事件发生时，处于无效状态的数据库触发器trigger 将不会被触发，此时就跟没有这个数据库触发器(trigger) 一样。
数据库trigger的这两种状态可以互相转换。格式为：
alter tigger trigger_name [disable | enable ];

--例：alter trigger emp_view_delete disable;
           
alter trigger语句一次只能改变一个触发器的状态，而alter table语句则一次能够改变
与指定表相关的所有触发器的使用状态。格式为：             
alter table [schema.]table_name {enable|disable} all triggers;

--例：使表emp 上的所有trigger 失效：
alter table emp disable all triggers; 
 
8.4 触发器和数据字典
相关数据字典：user_triggers、all_triggers、dba_triggers 
select trigger_name, trigger_type, triggering_event,
 table_owner, base_object_type, referencing_names,
 status, action_type
 from user_triggers;
*/
--8.5   数据库触发器的应用举例
--例1：创建一个dml语句级触发器，当对emp表执行insert, update, delete 操作时，它自动更新dept_summary 表中的数据。
-- 由于在pl/sql块中不能直接调用ddl语句，所以，利用oracle内置包dbms_utility中的exec_ddl_statement过程，由它执行ddl语句创建触发器。
 
create table dept_summary(
 deptno number(2),
 sal_sum number(9, 2),
 emp_count number); 

insert into dept_summary(deptno, sal_sum, emp_count)
 select deptno, sum(sal), count(*) 
from emp 
group by deptno;

--创建一个pl/sql过程disp_dept_summary
--在触发器中调用该过程显示dept_summary标中的数据。
create or replace procedure disp_dept_summary
is
 rec dept_summary%rowtype;
 cursor c1 is select * from dept_summary;
begin
 open c1;
 fetch c1 into rec;
 dbms_output.put_line('deptno    sal_sum    emp_count');
 dbms_output.put_line('-------------------------------------');
 while c1%found loop
    dbms_output.put_line(rpad(rec.deptno, 6)||
      to_char(rec.sal_sum, '$999,999.99')||
      lpad(rec.emp_count, 13));
    fetch c1 into rec;
 end loop;
 close c1;
end;
begin
 dbms_output.put_line('插入前');
 disp_dept_summary();
 dbms_utility.exec_ddl_statement('
    create or replace trigger trig1
      after insert or delete or update of sal on emp
    begin
      dbms_output.put_line(''正在执行trig1 触发器…'');
      delete from dept_summary;
      insert into dept_summary(deptno, sal_sum, emp_count)
      select deptno, sum(sal), count(*) 
      from emp group by deptno;
    end;
 ');


 insert into dept(deptno, dname, loc) 
 values(90, 'demo_dept', 'none_loc');
 insert into emp(ename, deptno, empno, sal)
 values(user, 90, 9999, 3000);

 dbms_output.put_line('插入后');
 disp_dept_summary();

 update emp set sal=1000 where empno=9999;
 dbms_output.put_line('修改后');
 disp_dept_summary();

 delete from emp where empno=9999;
 delete from dept where deptno=90;

 dbms_output.put_line('删除后');
 disp_dept_summary(); 
 dbms_utility.exec_ddl_statement('drop trigger trig1');
exception
   when others then
      dbms_output.put_line(sqlcode||'---'||sqlerrm);

end;
 
--例2：创建dml语句行级触发器。当对emp表执行insert, update, delete 操作时，它自动更新dept_summary 表中的数据。
-- 由于在pl/sql块中不能直接调用ddl语句，所以，利用oracle内置包dbms_utility中的exec_ddl_statement过程，由它执行ddl语句创建触发器。
begin
  dbms_output.put_line('插入前');
  disp_dept_summary();
  dbms_utility.exec_ddl_statement(
    'create or replace trigger trig2_update
      after update of sal on emp
      referencing old as old_emp new as new_emp
      for each row
      when (old_emp.sal != new_emp.sal)
    begin
      dbms_output.put_line(''正在执行trig2_update 触发器…'');
      dbms_output.put_line(''sal 旧值：''|| :old_emp.sal);
      dbms_output.put_line(''sal 新值：''|| :new_emp.sal);
      update dept_summary
        set sal_sum=sal_sum + :new_emp.sal - :old_emp.sal
        where deptno = :new_emp.deptno;
    end;'
  );
  
  dbms_utility.exec_ddl_statement(
    'create or replace trigger trig2_insert
      after insert on emp
      referencing new as new_emp
      for each row
    declare
      i number;
    begin
      dbms_output.put_line(''正在执行trig2_insert 触发器…'');
      select count(*) into i 
      from dept_summary where deptno = :new_emp.deptno;
      if i > 0 then
        update dept_summary 
        set sal_sum=sal_sum+:new_emp.sal,
        emp_count=emp_count+1
        where deptno = :new_emp.deptno;
      else
        insert into dept_summary
        values (:new_emp.deptno, :new_emp.sal, 1);
      end if;
    end;'
  );

  dbms_utility.exec_ddl_statement(
    'create or replace trigger trig2_delete
      after delete on emp
      referencing old as old_emp
      for each row
    declare
      i number;
    begin
      dbms_output.put_line(''正在执行trig2_delete 触发器…'');
      select emp_count into i 
      from dept_summary where deptno = :old_emp.deptno;
      if i >1 then
        update dept_summary 
        set sal_sum=sal_sum - :old_emp.sal,
        emp_count=emp_count - 1
        where deptno = :old_emp.deptno;
      else
        delete from dept_summary where deptno = :old_emp.deptno;
      end if;
    end;'
  );

  insert into dept(deptno, dname, loc) 
    values(90, 'demo_dept', 'none_loc');
  insert into emp(ename, deptno, empno, sal)
    values(user, 90, 9999, 3000);
  insert into emp(ename, deptno, empno, sal)
    values(user, 90, 9998, 2000);
  dbms_output.put_line('插入后');
  disp_dept_summary();

  update emp set sal = sal*1.1 where deptno=90;
  dbms_output.put_line('修改后');
  disp_dept_summary();

  delete from emp where deptno=90;
  delete from dept where deptno=90;
  dbms_output.put_line('删除后');
  disp_dept_summary();

  dbms_utility.exec_ddl_statement('drop trigger trig2_update');
  dbms_utility.exec_ddl_statement('drop trigger trig2_insert');
  dbms_utility.exec_ddl_statement('drop trigger trig2_delete');
exception
   when others then
      dbms_output.put_line(sqlcode||'---'||sqlerrm);
end;
 
--例3：利用oracle提供的条件谓词inserting、updating和deleting创建与例2具有相同功能的触发器。
 
begin
    dbms_output.put_line('插入前');
    disp_dept_summary();
    dbms_utility.exec_ddl_statement(
        'create or replace trigger trig2
            after insert or delete or update of sal
on emp
            referencing old as old_emp new as new_emp
            for each row
        declare
            i number;
        begin
            if updating and :old_emp.sal != :new_emp.sal then
            dbms_output.put_line(''正在执行trig2 触发器…'');
                dbms_output.put_line(''sal 旧值：''|| :old_emp.sal);
                dbms_output.put_line(''sal 新值：''|| :new_emp.sal);
                update dept_summary
                    set sal_sum=sal_sum + :new_emp.sal - :old_emp.sal
                where deptno = :new_emp.deptno;
            elsif inserting then
                dbms_output.put_line(''正在执行trig2触发器…'');
                select count(*) into i 
        from dept_summary 
        where deptno = :new_emp.deptno;
                if i > 0 then
                    update dept_summary 
          set sal_sum=sal_sum+:new_emp.sal,
              emp_count=emp_count+1
          where deptno = :new_emp.deptno;
            else
          insert into dept_summary
            values (:new_emp.deptno, :new_emp.sal, 1);
        end if;
      else
        dbms_output.put_line(''正在执行trig2触发器…'');
        select emp_count into i 
        from dept_summary where deptno = :old_emp.deptno;
      if i > 1 then
        update dept_summary 
        set sal_sum=sal_sum - :old_emp.sal,
        emp_count=emp_count - 1
        where deptno = :old_emp.deptno;
      else
          delete from dept_summary 
          where deptno = :old_emp.deptno;
      end if;
    end if;
    end;'
  );

  insert into dept(deptno, dname, loc) 
    values(90, 'demo_dept', 'none_loc');
  insert into emp(ename, deptno, empno, sal)
    values(user, 90, 9999, 3000);
  insert into emp(ename, deptno, empno, sal)
    values(user, 90, 9998, 2000);
  dbms_output.put_line('插入后');
  disp_dept_summary();

  update emp set sal = sal*1.1 where deptno=90;
  dbms_output.put_line('修改后');
  disp_dept_summary();

  delete from emp where deptno=90;
  delete from dept where deptno=90;
  dbms_output.put_line('删除后');
  disp_dept_summary();

  dbms_utility.exec_ddl_statement('drop trigger trig2');
exception
   when others then
      dbms_output.put_line(sqlcode||'---'||sqlerrm);
end;
 
--例4：创建instead of 触发器。首先创建一个视图myview,由于该视图是复合查询所产生的视图，所以不能执行dml语句。
-- 根据用户对视图所插入的数据判断需要将数据插入到哪个视图基表中，然后对该基表执行插入操作。
 
declare
    no number;
    name varchar2(20);
begin
    dbms_utility.exec_ddl_statement('
        create or replace view myview as
            select empno, ename, ''e'' type from emp
            union
            select dept.deptno, dname, ''d'' from dept
    ');
    -- 创建instead of 触发器trigger3;
    dbms_utility.exec_ddl_statement('
        create or replace trigger trig3
            instead of insert on myview
            referencing new n
            for each row
        declare
            rows integer;
        begin
            dbms_output.put_line(''正在执行trig3触发器…'');
            if :n.type = ''d'' then
                select count(*) into rows
                    from dept where deptno = :n.empno;
                if rows = 0 then
                    dbms_output.put_line(''向dept表中插入数据…'');
                    insert into dept(deptno, dname, loc)
                        values (:n.empno, :n.ename, ''none'');
                else
                    dbms_output.put_line(''编号为''|| :n.empno||''的部门已存在，插入操作失败！'');
                 end if;
            else
                select count(*) into rows
                    from emp where empno = :n.empno;
                if rows = 0 then
                    dbms_output.put_line(''向emp表中插入数据…'');
                    insert into emp(empno, ename)
                        values(:n.empno, :n.ename);
                else
                    dbms_output.put_line(''编号为''|| :n.empno||''的人员已存在，插入操作失败!'');
                end if;
            end if;
        end;
    ');

    insert into myview values (70, 'demo', 'd');
    insert into myview values (9999, user, 'e');
    select deptno, dname into no, name from dept where deptno=70;
    dbms_output.put_line('员工编号：'||to_char(no)||'姓名：'||name);
    select empno, ename into no, name from emp where empno=9999;
    dbms_output.put_line('部门编号：'||to_char(no)||'姓名：'||name);
  delete from emp where empno=9999;
  delete from dept where deptno=70;
    dbms_utility.exec_ddl_statement('drop trigger trig3');
end;
 
--例5：利用oracle事件属性函数，创建一个系统事件触发器。首先创建一个事件日志表eventlog，由它存储用户在当前数据库中所创建的数据库对象，
-- 以及用户的登陆和注销、数据库的启动和关闭等事件，之后创建trig4_ddl、trig4_before和trig4_after触发器，
-- 它们调用事件属性函数将各个事件记录到eventlog数据表中。
 
begin
    -- 创建用于记录事件日志的数据表
    dbms_utility.exec_ddl_statement('
        create table eventlog(
            eventname varchar2(20) not null,
            eventdate date default sysdate,
            inst_num number null,
            db_name varchar2(50) null,
            srv_error number null,
            username varchar2(30) null,
            obj_type varchar2(20) null,
            obj_name varchar2(30) null,
            obj_owner varchar2(30) null
        )
    ');

    -- 创建ddl触发器trig4_ddl
    dbms_utility.exec_ddl_statement('
        create or replace trigger trig4_ddl
            after create or alter or drop 
on database
        declare
            event varchar2(20);
            typ varchar2(20);
            name varchar2(30);
            owner varchar2(30);
        begin
            -- 读取ddl事件属性
            event := sysevent;
            typ := dictionary_obj_type;
            name := dictionary_obj_name;
            owner := dictionary_obj_owner;
            --将事件属性插入到事件日志表中
            insert into scott.eventlog(eventname, obj_type, obj_name, obj_owner)
                values(event, typ, name, owner);
        end;
    ');

    -- 创建logon、startup和servererror 事件触发器
    dbms_utility.exec_ddl_statement('
        create or replace trigger trig4_after
            after logon or startup or servererror 
      on database
        declare
            event varchar2(20);
            instance number;
            err_num number;
            dbname varchar2(50);
            user varchar2(30);
        begin
            event := sysevent;
            if event = ''logon'' then
                user := login_user;
                insert into eventlog(eventname, username)
                    values(event, user);
            elsif event = ''servererror'' then
                err_num := server_error(1);
                insert into eventlog(eventname, srv_error)
                    values(event, err_num);
            else
                instance := instance_num;
                dbname := database_name;
                insert into eventlog(eventname, inst_num, db_name)
                    values(event, instance, dbname);
      end if;
    end;
  ');

  -- 创建logoff和shutdown 事件触发器
  dbms_utility.exec_ddl_statement('
    create or replace trigger trig4_before
      before logoff or shutdown 
      on database
    declare
      event varchar2(20);
      instance number;
      dbname varchar2(50);
      user varchar2(30);
    begin
      event := sysevent;
      if event = ''logoff'' then
        user := login_user;
        insert into eventlog(eventname, username)
          values(event, user);
      else
        instance := instance_num;
        dbname := database_name;
        insert into eventlog(eventname, inst_num, db_name)
          values(event, instance, dbname);
      end if;
    end;
  ');
end;

create table mydata(mydate number);
connect scott/tiger

col eventname format a10
col eventdate format a12
col username format a10
col obj_type format a15
col obj_name format a15
col obj_owner format a10
select eventname, eventdate, obj_type, obj_name, obj_owner, username, srv_error
  from eventlog;

drop trigger trig4_ddl;
drop trigger trig4_before;
drop trigger trig4_after;
drop table eventlog;
drop table mydata;


-- 8.6   数据库触发器的应用实例
-- 用户可以使用数据库触发器实现各种功能：
-- l         复杂的审计功能；
-- 例：将emp 表的变化情况记录到audit_table和audit_table_values中。

create table audit_table(
    audit_id     number,
    user_name varchar2(20),
    now_time date,
    terminal_name varchar2(10),
    table_name varchar2(10),
    action_name varchar2(10),
    emp_id number(4));

create table audit_table_val(
    audit_id number,
    column_name varchar2(10),
    old_val number(7,2),
    new_val number(7,2));

create sequence audit_seq
    start with 1000
    increment by 1
    nomaxvalue
    nocycle nocache;

create or replace trigger audit_emp
    after insert or update or delete on emp
    for each row
declare
    time_now date;
    terminal char(10);
begin 
    time_now:=sysdate;
    terminal:=userenv('terminal');
    if inserting then
        insert into audit_table
    values(audit_seq.nextval, user, time_now, 
           terminal, 'emp', 'insert', :new.empno);
    elsif deleting then
        insert into audit_table
    values(audit_seq.nextval, user, time_now, 
           terminal, 'emp', 'delete', :old.empno);
    else
        insert into audit_table
    values(audit_seq.nextval, user, time_now, 
           terminal, 'emp', 'update', :old.empno);
        if updating('sal') then
            insert into audit_table_val
                values(audit_seq.currval, 'sal', :old.sal, :new.sal);
        else updating('deptno') 
            insert into audit_table_val
                values(audit_seq.currval, 'deptno', :old.deptno, :new.deptno);
        end if;
    end if;
end;
 
--l         增强数据的完整性管理；
--例：修改dept表的deptno列时，同时把emp表中相应的deptno也作相应的修改；
 
create sequence update_sequence 
    increment by 1
    start with 1000
    maxvalue 5000 cycle;

alter table emp
    add update_id number;

create or replace package integritypackage as
    updateseq number;
end integritypackage;

create or replace package body integritypackage as
end integritypackage;

create or replace trigger dept_cascade1
    before update of deptno on dept
declare 
    dummy number;
begin 
    select update_sequence.nextval into dummy from dual;
    integritypackage.updateseq:=dummy;
end;

create or replace trigger dept_cascade2
    after delete or update of deptno on dept
    for each row
begin
    if updating then
        update emp set deptno=:new.deptno, 
     update_id=integritypackage.updateseq
        where emp.deptno=:old.deptno and update_id is null;
    end if;
    if deleting then
        delete from emp
            where emp.deptno=:old.deptno;
    end if;
end;

create or replace trigger dept_cascade3
    after update of deptno on dept 
begin
    update emp set update_id=null
        where update_id=integritypackage.updateseq;
end;

select * from emp order by deptno;
update dept set deptno=25 where deptno=20;
 
--l         帮助实现安全控制；
--例：保证对emp表的修改仅在工作日的工作时间；
 
create table company_holidays(day date);

insert into company_holidays 
    values(sysdate);
insert into company_holidays 
values(to_date('21-10月-01', 'dd-mon-yy'));

create or replace trigger emp_permit_change
    before insert or delete or update on emp
declare
    dummy number;
    not_on_weekends exception;
    not_on_holidays exception;
    not_working_hours exception;
begin
    /* check for weekends */
if to_char(sysdate, 'day') in ('星期六', '星期日') then
    raise not_on_weekends;
end if;
    /* check for company holidays */
select count(*) into dummy from company_holidays
    where trunc(day)=trunc(sysdate);
if dummy >0 then
    raise not_on_holidays;
end if;
    /* check for work hours(8:00 am to 18:00 pm */
if (to_char(sysdate,'hh24')<8 or to_char(sysdate, 'hh24')>18) then
  raise not_working_hours;
end if;
exception
  when not_on_weekends then
    raise_application_error(-20324, 
'may not change employee table during the weekends'); 
  when not_on_holidays then
    raise_application_error(-20325, 
'may not change employee table during a holiday'); 
  when not_working_hours then
    raise_application_error(-20326, 
'may not change employee table during no_working hours'); 
end;
*/





/*
例1: 建立一个触发器, 当职工表 emp 表被删除一条记录时，把被删除记录写到职工表删除日志表中去。
*/ 
create table emp_his as select * from emp where 1=2; 
create or replace trigger tr_del_emp 
   before delete --指定触发时机为删除操作前触发
   on scott.emp 
   for each row   --说明创建的是行级触发器 
begin
   --将修改前数据插入到日志记录表 del_emp ,以供监督使用。
   insert into emp_his(deptno , empno, ename , job ,mgr , sal , comm , hiredate )
       values( :old.deptno, :old.empno, :old.ename , :old.job,:old.mgr, :old.sal, :old.comm, :old.hiredate );
end;
delete emp where empno=7788;
drop table emp_his;
drop trigger del_emp;


/*
例2：限制对departments表修改（包括insert,delete,update）的时间范围，即不允许在非工作时间修改

departments表。
*/
create or replace trigger tr_dept_time
before insert or delete or update 
on departments
begin
 if (to_char(sysdate,'day') in ('星期六', '星期日')) or (to_char(sysdate, 'hh24:mi') not between 

'08:30' and '18:00') then
     raise_application_error(-20001, '不是上班时间，不能修改departments表');
 end if;
end;


/*
例3：限定只对部门号为80的记录进行行触发器操作。
*/
create or replace trigger tr_emp_sal_comm
before update of salary, commission_pct
       or delete
on hr.employees
for each row
when (old.department_id = 80)
begin
 case
     when updating ('salary') then
        if :new.salary < :old.salary then

           raise_application_error(-20001, '部门80的人员的工资不能降');
        end if;
     when updating ('commission_pct') then

        if :new.commission_pct < :old.commission_pct then
           raise_application_error(-20002, '部门80的人员的奖金不能降');
        end if;
     when deleting then
          raise_application_error(-20003, '不能删除部门80的人员记录');
     end case;
end; 

/*
实例：
update employees set salary = 8000 where employee_id = 177;
delete from employees where employee_id in (177,170);
*/


/*
例4：利用行触发器实现级联更新。在修改了主表regions中的region_id之后（after），级联的、自动的更新子表

countries表中原来在该地区的国家的region_id。
 */
 
create or replace trigger tr_reg_cou
after update of region_id
on regions
for each row
begin
 dbms_output.put_line('旧的region_id值是'||:old.region_id
                  ||'新的region_id值是'||:new.region_id);
 update countries set region_id = :new.region_id
 where region_id = :old.region_id;
end;



/*
例5：在触发器中调用过程。
*/ 
create or replace procedure add_job_history
 ( p_emp_id            job_history.employee_id%type
   , p_start_date      job_history.start_date%type
   , p_end_date        job_history.end_date%type
   , p_job_id          job_history.job_id%type
   , p_department_id   job_history.department_id%type
   )
is
begin
 insert into job_history (employee_id, start_date, end_date,
                           job_id, department_id)
  values(p_emp_id, p_start_date, p_end_date, p_job_id, p_department_id);
end add_job_history;


--例6：创建instead of 触发器。首先创建一个视图myview,由于该视图是复合查询所产生的视图，所以不能执行dml
-- 语句。根据用户对视图所插入的数据判断需要将数据插入到哪个视图基表中，然后对该基表执行插入操作。
 
declare
    no number;
    name varchar2(20);
begin
    dbms_utility.exec_ddl_statement('
        create or replace view myview as
            select empno, ename, ''e'' type from emp
            union
            select dept.deptno, dname, ''d'' from dept
    ');
    -- 创建instead of 触发器trigger3;
    dbms_utility.exec_ddl_statement('
        create or replace trigger trig3
            instead of insert on myview
            referencing new n
            for each row
        declare
            rows integer;
        begin
            dbms_output.put_line(''正在执行trig3触发器…'');
            if :n.type = ''d'' then
                select count(*) into rows
                    from dept where deptno = :n.empno;
                if rows = 0 then
                    dbms_output.put_line(''向dept表中插入数据…'');
                    insert into dept(deptno, dname, loc)
                        values (:n.empno, :n.ename, ''none'');
                else
                    dbms_output.put_line(''编号为''|| :n.empno||''的部门已存在，插入操作失败！'');
                 end if;
            else
                select count(*) into rows
                    from emp where empno = :n.empno;
                if rows = 0 then
                    dbms_output.put_line(''向emp表中插入数据…'');
                    insert into emp(empno, ename)
                        values(:n.empno, :n.ename);
                else
                    dbms_output.put_line(''编号为''|| :n.empno||''的人员已存在，插入操作失败!'');
                end if;
            end if;
        end;
    ');

    insert into myview values (70, 'demo', 'd');
    insert into myview values (9999, user, 'e');
    select deptno, dname into no, name from dept where deptno=70;
    dbms_output.put_line('员工编号：'||to_char(no)||'姓名：'||name);
    select empno, ename into no, name from emp where empno=9999;
    dbms_output.put_line('部门编号：'||to_char(no)||'姓名：'||name);
    delete from emp where empno=9999;
    delete from dept where deptno=70;
    dbms_utility.exec_ddl_statement('drop trigger trig3');
end;



--创建触发器调用存储过程...
create or replace trigger update_job_history
 after update of job_id, department_id on employees
 for each row
begin
 add_job_history(:old.employee_id, :old.hire_date, sysdate,
                  :old.job_id, :old.department_id);
end;



create or replace trigger emp_view_delete
   instead of delete on emp_view for each row
begin
   delete from emp where deptno= :old.deptno;
end emp_view_delete; 



create or replace trigger "hr"."tr_i_o_reg_cou" instead of
 insert on v_reg_cou for each row declare v_count number;
begin
 select count(*) into v_count from regions where region_id = :new.r_id;
 if v_count = 0 then
    insert into regions
      (region_id, region_name
      ) values
      (:new.r_id, :new.r_name
      );
 end if;

 select count(*) into v_count from countries where country_id = :new.c_id;
 if v_count = 0 then
    insert
    into countries
      (
        country_id,
        country_name,
        region_id
      )
      values
      (
        :new.c_id,
        :new.c_name,
        :new.r_id
      );
 end if;
end;



--创建用于记录事件用的表

create table ddl_event
(crt_date timestamp primary key,
 event_name varchar2(20), 
 user_name varchar2(10),
 obj_type varchar2(20),
 obj_name varchar2(20));

--创建触发器
create or replace trigger tr_ddl
after ddl on schema
begin
   insert into ddl_event values
   (systimestamp,ora_sysevent, ora_login_user, 
    ora_dict_obj_type, ora_dict_obj_name);
end tr_ddl;



--例2：创建登录、退出触发器。
 
create table log_event
(user_name varchar2(10),
 address varchar2(20), 
 logon_date timestamp,
 logoff_date timestamp); 

--创建登录触发器
create or replace trigger tr_logon
after logon on database
begin
   insert into log_event (user_name, address, logon_date)
   values (ora_login_user, ora_client_ip_address, systimestamp);
end tr_logon;
--创建退出触发器
create or replace trigger tr_logoff
before logoff on database
begin
   insert into log_event (user_name, address, logoff_date)
   values (ora_login_user, ora_client_ip_address, systimestamp);
end tr_logoff;


create or replace trigger dept_cascade1
    before update of deptno on dept
declare 
    dummy number;
begin 
    select update_sequence.nextval into dummy from dual;
    integritypackage.updateseq:=dummy;
end;




-- 常用函数
select to_char(systimestamp,'yyyymmdd hh:mi:ss') from dual;

select * from product_component_version where lower(substr(product,1,6)) = 'oracle'; 

select * from db001_owner.xods_bosdb_item@dblinktodsj






-- 20.创建函数
create [or replace] function functionname  
(  
    parametername1 mode1 datatype1,  

    parametername2 mode2 datatype2,  
    ...  
)  
return returndatatype  
is/as  
begin  
    function_body  
    return expression  
end functionname; 
-- 结束函数的声明，也可以直接写end不加函数名。
--其中mode1、mode2表示参数类型，datatype表示参数的数据类型。returndatatype表示返回值类型。


--创建函数
create or replace function get_hello_msg 
return varchar2 as
begin 
  return 'hello world';
end get_hello_msg;

-- 无参函数
create or replace function fun_dtime return varchar2
as
begin
return to_char(sysdate,'yyyy"年"mm"月"dd"日"');
end;

-- 调用
begin
dbms_output.put_line(fun_dtime);
end;


-- 带输入输出参数的函数
create or replace function fun_info(i_eno number,o_title out varchar2,salch in out number) 
  return varchar2
as
name emp.ename%type;
begin
select ename into name from emp where empno=i_eno;
update emp set sal=sal+salch where empno=i_eno returning job,sal into o_title,salch;
return name;
end;
-- 调用
declare
v_eno number:=7369;
vn emp.ename%type;
vj emp.job%type;
vs emp.sal%type;
begin
vs:=100;
vn:=fun_info(v_eno,vj,vs);
dbms_output.put_line('姓名' || vn || '岗位' || vj || '新工资' || vs);
end;


-- 删除函数
drop function fun_info;

--function
/*
函数是有返回值。-只能有一个返回值。

语法
    create or replace func1(参数)
        return varchar2
   as
        pl/sql块
        return 'jack';

*/
--创建和调用

create or replace  function f1
return varchar2
as
--声明变量
begin
return 'jack';
end;
select f1()from dual;
--在plsql使用
set serveroutput on;
declare
v_name varchar2(30);
begin
--直接调用值调用
v_name:=f1();
dbms_output.put_line('name is'||v_name);
end;
---接受参数的函数
create or replace function f2(p_w varchar2)
return varchar2
as
v_f char(1);
v_a varchar2(500);
begin
--判断是否有数据
if p_w is null then
return null;
end if;
if length(p_w)=0 then
return null;
end if;
--取第一个字
v_f :=substr(p_w,1,1);
--去剩余
v_a:=substr(p_w,2);
v_a:=lower(v_a);--小写
v_f:=upper(v_f);
--新
v_a:=v_f||v_a;
return v_a;
end;

--测试
select f2('abdsds') from dual;
--abdsds



create or replace function fn_mymonth(oridate in date)
return varchar2
as
  oriday number;
  orimonth number;
  oriyear number; 
begin
  oriday := to_number(to_char(oridate, 'dd'));
  orimonth := to_number(to_char(oridate, 'mm'));
  oriyear := to_number(to_char(oridate, 'yyyy'));
 
  if oriday <= 15 then                              --少于等于15号属于本月
    return to_char(oridate, 'yyyymm');
  else
    if orimonth <= 8 then                           -- 日 <=8 则+1后转char还要补0,单独出来作为一种情况
      return to_char(oriyear)||'0'||to_char(orimonth + 1);
    elsif( orimonth <= 11 ) then                    -- 日 <= 11则+1后不会跨年,转char不需要补零, 单独出来作为一种情况
      return to_char(oriyear)||to_char(orimonth + 1);
    else                                            -- 最后一种情况就是跨年, 改变年份, 月份补零就行
      return to_char(oriyear + 1)||'0'||to_char(orimonth - 11);
    end if;
  end if;
end fn_mymonth;

-- select fn_mymonth(to_date('2015-12-14', 'yyyy-mm-dd')) from dual;

--查看函数的类型和状态
select object_name, object_type, status from user_objects where lower(object_name)='get_hello_msg';

select name,type,line,text from user_source where lower(name)='get_hello_msg';
select get_hello_msg() from dual;


create or replace
  function get_tax(p_salary number)
  return number as
  begin
    declare tax_salary number;
    begin
    tax_salary := p_salary - 2000;
    if tax_salary<=0 then
       return 0;
    end if;
    
    if tax_salary<=500 then
      return tax_salary*5/100;
    end if;
    
    if tax_salary<=2000 then
      return tax_salary*10/100 - 25;
    end if;
    
    if tax_salary<=5000 then
       return tax_salary*15/100 - 125;
    end if;
    
    if tax_salary<=20000 then
       return tax_salary*20/100 - 375;
    end if;
    
    if tax_salary<= 40000 then
       return tax_salary*25/100 - 1375;
    end if;
    
    if tax_salary<= 60000 then
       return tax_salary*30/100 - 3375;
    end if;
    
  end;
  end get_tax;


create or replace 
   function get_student_string
   return varchar2
   as
   begin
      declare cursor cu_student is
       select student_name from students       
       order by student_id;
      student_nane varchar2(10);
      rowstring varchar2(500);
      
      begin
       open cu_student;
       fetch cu_student into student_name;  --将游标所指向的当前记录的数据赋值给student_name
       
       while cu_student%found loop       --用于循环处理游标所指向的记录
         rowstring:=rowstring || student_name || ', ';
         fetch cu_student into student_name;
       end loop;
       
       return substr(rowstring, 1, length(rowstring) - 1);
    end;
    end get_student_string;



--自定义函数
create or replace function isnumber(p_in varchar2) return boolean as i number;  
begin
     i:=to_number(p_in);  
     return true;  
exception
     when others then
     return false;  
end;




-- 21.创建包
create or replace package "pkg_dim_area" is
  procedure p_dim_area (pi_batchno   in number);

end pkg_dim_area ;


create or replace package body "pkg_dim_area" is
  procedure p_dim_area
  (pi_batchno   in number ) as
  begin
   
    --插入与更新
    merge into dim_area a
    using (select xxx from org_orginfo org ) b
    on (a.sk_area = b.sk_org)
    when matched then
      update
         set a.arealevel = b.org_level
           
    when not matched then
      insert(
        sk_area
         )
      values
        (b.sk_org
         );
 
    commit ;
  end  p_dim_area;
end pkg_dim_area;



-- 22.创建临时表
create global temporary table aaa_tmp_sale_trace
(
  da_ie_id          number(10),  --销售订单唯一序列号
  deal_id           varchar2(12),  --销售订单号
  buy_deal          varchar2(30),  --成本报价表 采购单号
  sale_deal         varchar2(4000),  --成本报价表 销售单号
  apply_broker      varchar2(20),  --销售订单经办人
  operat_name       varchar2(20),  --销售订单操作人
  cmd_id            varchar2(150),  --客户名称
  other_code        varchar2(30),  --销售合同号
  cont_no           varchar2(300),  --销售序列号
  part_no           varchar2(30),  --件号
  replace_part_no   varchar2(100),  --替换件号
  descript          varchar2(100),  --描述
  compute_unit      varchar2(10),  --单位
  unit_qty          number,  --销售数量
  stock_unit_qty    number,  --库存数量
  p_unit_qty        number,  --采购数量
  o_unit_qty        number,  --出库数量
  foreign_price     number,  --外币价格
  foreign_amount    number,  --外币总价
  sign_date         varchar2(20),  --合同签订日期
  deliver_date      varchar2(60),  --承诺发货期
  purchase_contract varchar2(30),  --采购合同号
  product_state     varchar2(60),  --采购表的采购产品状态
  contact_man       varchar2(30),  --订货人
  state             varchar2(30),  --状态（完成，未完成）
  send_state        varchar2(6),  --发货日期
  inquiry_id        number(10),  --销售订单字表中的序列号
  memo              varchar2(300),  --销售订单子表备注
  p_inquriy_id      number(10)  --采购订单序列号
)
on commit preserve rows



-- 23.创建表空间，临时表空间
--创建表空间
create undo tablespace tbs_users datafile 'd:\app\administrator\oradata\orcl\users01.dbf' size 10m reuse autoextend 
  on next 10m maxsize 2048m


--扩展表空间
alter tablespace users add datafile 'd:\app\administrator\oradata\orcl\users02.dbf' size 100 m autoextend 
on next 10m maxsize 2048m

-- 关闭表空间自动扩展
alter tablespace users add datafile 'd:\app\administrator\oradata\orcl\users02.dbf' size 10000 m autoextend off;


-- 增加表空间大小的四种方法
-- 1.给表空间增加数据文件
alter tablespace app_data add datafile  
'd:\oracle\product\10.2.0\oradata\edwtest\app03.dbf' size 50m; 
-- 2.新增数据文件，并且允许数据文件自动增长
alter tablespace app_data add datafile  
'd:\oracle\product\10.2.0\oradata\edwtest\app04.dbf' size 50m  
autoextend on next 5m maxsize 100m;
-- 3.允许已存在的数据文件自动增长
alter database datafile 'd:\oracle\product\10.2.0\oradata\edwtest\app03.dbf'  
autoextend on next 5m maxsize 100m;
-- 4.手工改变已存在数据文件的大小
alter database datafile 'd:\oracle\product\10.2.0\oradata\edwtest\app02.dbf'  
resize 100m;




-- 扩展临时表空间
alter tablespace temp add tempfile 'd:\app\administrator\oradata\orcl\temp01.dbf' size 20480k reuse autoextend 
on next 640k maxsize unlimited;


--指定用户使用哪个表空间
alter system set undo_tablespace=users scope=spfile

alter system set undo_management=auto scope=spfile
--查询用户对应的哪个表空间
select username,default_tablespace from dba_users  where username='tocall';



-- 查询表空间名
select tablespace_name from dba_tablespaces where tablespace_name='users';

-- 1、查看所有表空间及表空间大小：
select tablespace_name ,sum(bytes) / 1024 / 1024 as mb　from dba_data_files group by tablespace_name;

-- 2、查看所有表空间对应的数据文件：
select tablespace_name,file_name from dba_data_files;

-- 3、修改数据文件大小：
alter database datafile 'h:\oracle\product\10.1.0\oradata\oracle\users01.dbf' resize 10240m;


-- 查看表空间的使用率，没有临时表空间
select  upper(a.tablespace_name)              "表空间名",
        b.tot_grootte_mb                      "表空间大小(m)",
        b.tot_grootte_mb - a.total_bytes      "已使用空间(m)",
        to_char(round(( b.tot_grootte_mb - a.total_bytes ) / b.tot_grootte_mb * 100, 2), '990.99') || '%'  "使用比",
        a.total_bytes                         "空闲空间(m)",
        a.max_bytes                           "最大块(m)"
from  (
  select  tablespace_name,
          round(sum(bytes) / ( 1024 * 1024 ), 2) total_bytes,
          round(max(bytes) / ( 1024 * 1024 ), 2) max_bytes
  from  sys.dba_free_space
  group by tablespace_name
) a,
(
  select c.tablespace_name, round(sum(c.bytes) / ( 1024 * 1024 ), 2) tot_grootte_mb
  from  sys.dba_data_files c
  group by c.tablespace_name
) b
where b.tablespace_name = a.tablespace_name
order by 4 desc;


-- 查询所有表空间使用情况,包括临时表空间以及路径
select a.tablespace_name, 
a.file_name, 
to_char(a.bytes / 1024 / 1024, '99,999.999') total_bytes, 
to_char(b.bytes / 1024 / 1024, '99,999.999') free_bytes, 
to_char(a.bytes / 1024 / 1024 - b.bytes / 1024 / 1024, '99,999.999') use_bytes, 
to_char((1 - b.bytes / a.bytes) * 100, '99.99') || '%' use 
from (select tablespace_name, file_name, file_id, sum(bytes) bytes 
from dba_data_files 
group by tablespace_name, file_name, file_id) a, 
(select tablespace_name, file_id, sum(bytes) bytes 
from dba_free_space 
group by tablespace_name, file_id) b 
where a.tablespace_name = b.tablespace_name 
and a.file_id = b.file_id 
union all 
select c.tablespace_name, c.file_name, 
to_char(c.bytes / 1024 / 1024, '99,999.999') total_bytes, 
to_char((c.bytes - d.bytes_used) / 1024 / 1024, '99,999.999') free_bytes, 
to_char(d.bytes_used / 1024 / 1024, '99,999.999') use_bytes, 
to_char(d.bytes_used * 100 / c.bytes, '99.99') || '%' use 
from (select tablespace_name,file_id, file_name, sum(bytes) bytes 
from dba_temp_files 
group by tablespace_name,file_id, file_name) c, 
(select tablespace_name,file_id, sum(bytes_cached) bytes_used 
from v$temp_extent_pool 
group by tablespace_name,file_id) d 
where c.tablespace_name = d.tablespace_name 
and c.file_id = d.file_id
order by 5 desc;


-- 查看表空间(查看所有表空间)使用率
select * from (
       select a.tablespace_name,
       to_char(a.bytes/1024/1024,'99,999.999') total_bytes,
       to_char(b.bytes/1024/1024,'99,999.999') free_bytes,
       to_char(a.bytes/1024/1024 - b.bytes/1024/1024,'99,999.999') use_bytes,
       to_char((1 - b.bytes/a.bytes)*100,'99.99') || '%'use
       from (select tablespace_name,
            sum(bytes) bytes
            from dba_data_files
            group by tablespace_name
       ) a,
       (select tablespace_name,
        sum(bytes) bytes
        from dba_free_space
        group by tablespace_name) b
        where a.tablespace_name = b.tablespace_name
        union all
        select c.tablespace_name,
        to_char(c.bytes/1024/1024,'99,999.999') total_bytes,
        to_char( (c.bytes-d.bytes_used)/1024/1024,'99,999.999') free_bytes,
        to_char(d.bytes_used/1024/1024,'99,999.999') use_bytes,
        to_char(d.bytes_used*100/c.bytes,'99.99') || '%'use
        from(select tablespace_name,sum(bytes) bytes
                from dba_temp_files group by tablespace_name
        ) c,
        (select tablespace_name,sum(bytes_cached) bytes_used
        from v$temp_extent_pool group by tablespace_name) d
        where c.tablespace_name = d.tablespace_name
)
order by 5 desc;


-- 查看使用消耗临时表空间资源比较多的sql语句：
select se.username, se.sid, su.extents, su.blocks * to_number(rtrim(p.value)) asspace, tablespace, segtype, sql_text
from v$sort_usage su, v$parameter p, v$session se, v$sql s
where p.name = 'db_block_size'
and su.session_addr = se.saddr
and s.hash_value = su.sqlhash
and s.address = su.sqladdr
order by se.username, se.sid;

-- 查询哪个sql语句占用资源较多
-- 从v$sqlarea中查询最占用资源的查询
select b.username username,a.disk_reads reads, 
a.executions exec,a.disk_reads/decode(a.executions,0,1,a.executions) rds_exec_ratio, 
a.sql_text statement 
from v$sqlarea a,dba_users b 
where a.parsing_user_id=b.user_id 
and a.disk_reads > 100000 
order by a.disk_reads desc; 

-- 列出使用频率最高的5个查询
select sql_text,executions 
from (select sql_text,executions, 
rank() over 
(order by executions desc) exec_rank 
from v$sql) 
where exec_rank <=5; 


-- 消耗磁盘读取最多的sql top5
select disk_reads,sql_text 
from (select sql_text,disk_reads, 
dense_rank() over 
(order by disk_reads desc) disk_reads_rank 
from v$sql) 
where disk_reads_rank <=5; 

-- 找出需要大量缓冲读取（逻辑读）操作的查询
select buffer_gets,sql_text 
from (select sql_text,buffer_gets, 
dense_rank() over 
(order by buffer_gets desc) buffer_gets_rank 
from v$sql) 
where buffer_gets_rank<=5;

-- 持续跟踪有性能影响的sql
select * from (
select parsing_user_id,executions,sorts,
command_type,disk_reads,sql_text from v$sqlarea
order by disk_reads desc
)
where rownum<10


select sql_text from v$sql where sql_id='dg5t8nfkaz8nk';
select ash.* from gv$active_session_history ash;


-- 查找最近一分钟内，最消耗cpu的sql语句
select ash.inst_id,
        ash.sql_id,
        (select vs.sql_text
           from gv$sqlarea vs
          where vs.sql_id = ash.sql_id
            and ash.inst_id = vs.inst_id) sql_text,
        ash.sql_child_number,
        ash.session_info,
        counts,
        pctload * 100 || '%' pctload
from (select ash.inst_id,
            ash.sql_id,
            ash.sql_child_number,
            (ash.module || '--' || ash.action || '--' || ash.program || '--' ||ash.client_id || '--' ||
            ash.session_type) session_info,
            count(*) counts,
            round(count(*) / sum(count(*)) over(), 2) pctload,
            dense_rank() over(order by count(*) desc) rank_order
       from gv$active_session_history ash
      where  ash.session_type <> 'background'
       and ash.session_state = 'on cpu'
and sample_time > sysdate - 1 / (24 * 60)
      group by ash.inst_id,
               ash.sql_id,
               ash.sql_child_number,
               (ash.module || '--' || ash.action || '--' || ash.program || '--' || ash.client_id || '--' ||
               ash.session_type)) ash
where rank_order <= 10
order by counts desc;


-- 查找最近一分钟内，最消耗cpu的会话
select session_id, count(*)
from   v$active_session_history v
where  v.session_state = 'on cpu'
and    v.sample_time > sysdate - 10/ (24 * 60)
group by session_id
order by count(*) desc;



-- 查找最近一分钟内，最消耗i/o的sql语句
select ash.inst_id,
        ash.sql_id,
        (select vs.sql_text
           from gv$sqlarea vs
          where vs.sql_id = ash.sql_id
            and ash.inst_id = vs.inst_id) sql_text,
        ash.sql_child_number,
        ash.session_info,
        counts,
        pctload * 100 || '%' pctload
from (select ash.inst_id,
            ash.sql_id,
            ash.sql_child_number,
            (ash.module || '--' || ash.action || '--' || ash.program || '--' || ash.client_id || '--' ||
            ash.session_type) session_info,
            count(*) counts,
            round(count(*) / sum(count(*)) over(), 2) pctload,
            dense_rank() over(order by count(*) desc) rank_order
       from gv$active_session_history ash
      where ash.session_type <> 'background'
        and ash.session_state = 'waiting'
        and ash.sample_time > sysdate - 1 / (24 * 60)
        and ash.wait_class = 'user i/o'
      group by ash.inst_id,
               ash.sql_id,
               ash.sql_child_number,
               (ash.module || '--' || ash.action || '--' || ash.program || '--' || ash.client_id || '--' ||
               ash.session_type)) ash
where rank_order <= 10
order by counts desc;


-- 查找最近一分钟内，最消耗资源的sql语句：
select ash.inst_id,
        ash.sql_id,
        (select vs.sql_text
           from gv$sqlarea vs
          where vs.sql_id = ash.sql_id
            and ash.inst_id = vs.inst_id) sql_text,
        ash.sql_child_number,
        ash.session_info,
        counts,
        pctload * 100 || '%' pctload
from (select ash.inst_id,
            ash.sql_id,
            ash.sql_child_number,
            (ash.module || '--' || ash.action || '--' || ash.program || '--' ||
            '--' || ash.client_id || '--' ||
            ash.session_type) session_info,
            count(*) counts,
            round(count(*) / sum(count(*)) over(), 2) pctload,
            dense_rank() over(order by count(*) desc) rank_order
       from gv$active_session_history ash
      where ash.session_type <> 'background'
        and ash.session_state = 'waiting'
        and ash.sample_time > sysdate - 1 / (24 * 60)
        and ash.wait_class = 'user i/o'
      group by ash.inst_id,
               ash.sql_id,
               ash.sql_child_number,
               (ash.module || '--' || ash.action || '--' || ash.program || '--' ||
               '--' || ash.client_id || '--' ||
               ash.session_type)) ash
where rank_order <= 10
order by counts desc;


-- 查找最近一分钟内，最消耗资源的会话
select ash.session_id,
       ash.session_serial#,
       ash.user_id,
       ash.program,
       sum(decode(ash.session_state, 'on cpu', 1, 0)) "cpu",
       sum(decode(ash.session_state, 'waiting', 1, 0)) -
       sum(decode(ash.session_state,
                  'waiting',
                  decode(ash.wait_class, 'user i/o', 1, 0),
                  0)) "waiting",
       sum(decode(ash.session_state,
                  'waiting',
                  decode(ash.wait_class, 'user i/o', 1, 0),
                  0)) "io",
       sum(decode(ash.session_state, 'on cpu', 1, 1)) "total"
from v$active_session_history ash
where ash.sample_time > sysdate - 1 / (24 * 60)
group by ash.session_id, ash.user_id, ash.session_serial#, ash.program
order by sum(decode(ash.session_state, 'on cpu', 1, 1));  



-- 查看总消耗时间最多的前100条sql语句
select *
from (select v.sql_id,
v.child_number,
v.sql_text,
last_load_time,
v.parsing_user_id,
round(v.elapsed_time / 1000000 / (case
               when (executions = 0 or nvl(executions, 1 ) = 1) then
                1
               else
                executions
             end),
             2) "执行时间's'",
 v.sql_fulltext,
v.cpu_time,
v.disk_reads,
rank() over(order by v.elapsed_time desc) elapsed_rank
from v$sql v  ) a
where elapsed_rank <= 100  and   last_load_time > to_char(sysdate - 1/24, 'yyyy-mm-dd/hh:mi:ss')    
order by "执行时间's'" desc


-- 查询最近一小时内最慢的sql:
select executions, cpu_time/1e6 as cpu_sec, elapsed_time/1e6 as elapsed_sec, 
round(elapsed_time/sqrt(executions)) as important, v.* 
from v$sql v 
where executions > 10 and last_load_time > to_char(sysdate - 1/24, 'yyyy-mm-dd/hh:mi:ss')  
order by important desc





-- 查看cpu消耗时间最多的前10条sql语句
select *
from (select v.sql_id,
v.child_number,
v.sql_text,
v.elapsed_time,
v.cpu_time,
v.disk_reads,
rank() over(order by v.cpu_time desc) elapsed_rank
from v$sql v) a
where elapsed_rank <= 10;


-- 查看消耗磁盘读取最多的前10条sql语句
select *
from (select v.sql_id,
v.child_number,
v.sql_text,
v.elapsed_time,
v.cpu_time,
v.disk_reads,
rank() over(order by v.disk_reads desc) elapsed_rank
from v$sql v) a
where elapsed_rank <= 10;


-- 执行过的sql
select 
    sql_id, hash_value, address, sql_fulltext,last_load_time 
from 
    v$sql 
order by 
    last_load_time desc; 
------------------------------------------------------------------------------------------------- 
select 
    sql_id, hash_value, address, b.sql_fulltext, b.first_load_time 
from 
    v$sqlarea b 
order by 
    b.first_load_time desc;


-- 正在执行的sql
select ssn.username, ssn.sid, ssn.sql_id,saa.address, saa.hash_value, saa.sql_fulltext
from v$session ssn, v$sqlarea saa 
where ssn.sql_address = saa.address and ssn.sql_hash_value = saa.hash_value;


-- 读取磁盘次数最多的sql
select * from (
    select 
        sql_id,address,hash_value,command_type, parsing_user_id, parsing_schema_name, 
        executions, sorts, disk_reads, buffer_gets, cpu_time, sql_fulltext 
    from 
        v$sqlarea 
    order by 
        disk_reads desc 
) where rownum<10 ; 


-- 消耗cpu时间最多的sql
select * from (
    select 
        sql_id,address,hash_value,command_type, parsing_user_id, parsing_schema_name, executions, sorts, disk_reads, buffer_gets, cpu_time, sql_fulltext 
    from 
        v$sqlarea 
    order by 
        cpu_time desc  
)where rownum<10 ; 



-- 执行次数最多的sql
select * from (
    select 
        sql_id,address,hash_value,command_type, parsing_user_id, parsing_schema_name, executions, sorts, disk_reads, buffer_gets, cpu_time, sql_fulltext 
    from 
        v$sqlarea 
    order by 
        executions desc  
)where rownum<10 ;



-- 查询当前耗时的会话id，用户名，sqlid
select sid,serial#,machine,username,program,sql_hash_value,sql_id,
       to_char(logon_time,'yyyy/mm/dd hh24:mi:ss') as login_time from v$session
where paddr in (select addr from v$process where spid in ('5648612','256523'));
-- 根据上述语句查出hash_value和sql_id查询耗时的sql
select sql_text
  from v$sqltext_with_newlines
  where hash_value = &hash_value
order by piece;

select * from v$sql where sql_id=''


-- 查询当前耗时的sql,会弹出输入框需要输入pid
select sql_text
  from v$sqltext a
where (a.hash_value, a.address) in
       (select decode(sql_hash_value, 0, prev_hash_value, sql_hash_value),
               decode(sql_hash_value, 0, prev_sql_addr, sql_address)
          from v$session b
         where b.paddr = (select addr from v$process c where c.spid = '&pid'))
order by piece asc



-- 查询oracle数据库占用资源比较大的对象
select b.username,
b.sid,
a.sql_id, 
a.sql_text,
a.sql_fulltext, 
b.event,
a.executions, 
-- trunc(((decode(a.executions,0,0,a.cpu_time / a.executions)) / 10000)) c_time, ---单位零点秒
trunc(((decode(a.executions,0,0,a.elapsed_time / a.executions)) / 10000)) e_time, 
--trunc(cpu_time/10000) cpu_time, 
trunc(a.elapsed_time/10000) elapsed_time , 
a.disk_reads,
a.buffer_gets,
b.machine,
b.program 
from v$sqlarea a, v$session b
where executions > =0
and b.status = 'active'
and a.sql_id = b.sql_id
-- and b.username='db_wtdz'
-- and trunc(((a.cpu_time / a.executions) / 1000000))>5


-- 查询每台机器的连接数
-- 每台机器是指每个连接oracle数据库的服务器，每个服务器都有配置连接数据库的连接数，
-- 以websphere为例，在数据源中，每个数据源都有配置其最大/最小连接数
select t.machine,count(*) from v$session t group by t.machine

-- 查询每个连接数的sql_text
select t.sql_hash_value,t.*  from v$session t where t.machine='web3' and t.sql_hash_value!=0


-- 查询每个活动的连接执行什么sql
-- username是执行sql的数据库用户名，一个sql_hash_value下的sql_text组合成一个完整的sql语句。
-- 这样就可以看到一个连接执行了哪些sql
select sid,username,sql_hash_value,b.sql_text
from v$session a,v$sqltext b
where a.sql_hash_value = b.hash_value and a.machine='web3'
order by sid,username,sql_hash_value,b.piece


-- 从v$sqlarea中查询最占用资源的查询
-- 用buffer_gets列来替换disk_reads列可以得到占用最多内存的sql语句的相关信息。
select b.username username,a.disk_reads reads, a.executions exec,
　　a.disk_reads/decode(a.executions,0,1,a.executions) rds_exec_ratio,
　　a.sql_text statement
　　from  v$sqlarea a,dba_users b
　　where a.parsing_user_id=b.user_id
　　and a.disk_reads > 100000
　　order by a.disk_reads desc;












-- 查看表空间状态，文件路径等信息
select * from dba_temp_files;
--查询临时文件是否在线：
select name,status from v$tempfile;

--查询用户所使用的临时表空间：
select username,default_tablespace,temporary_tablespace from dba_users;

-- 查看普通数据文件是否扩展
select d.file_name,d.tablespace_name,d.autoextensible from dba_data_files d;

-- 查看临时表空间是否可以扩展，查询临时表空间大小以及使用率
select d.file_name,d.tablespace_name,d.autoextensible from dba_temp_files d;

-- 临时表空间的使用情况
-- 查询临时表空间大小以及使用率：
select tablespace_name, bytes, user_bytes, user_bytes/bytes,file_name from dba_temp_files;


--修改临时文件在线(离线)状态：
alter database tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp02.dbf' online(offline);

--增加临时文件大小(增加原文件)：
alter database tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp01.dbf' resize 100m;

--通过增加新的临时文件，来扩大临时表空间：
alter tablespace temp add tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp02.dbf' size 4000m;

--删除临时文件：
alter database tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp02.dbf' drop;

--将临时文件设置为自动扩展：
alter database tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp01.dbf' autoextend on next 5m maxsize unlimited;

--关闭(启动)临时文件的自动增长：
alter database tempfile 'd:\oracle\product\10.2.0\oradata\orcl\temp01.dbf' autoextend off(on);



-- 执行添加临时表空间的数据文件命令：
alter tablespace temp
 addtempfile'/home/oradata/powerdes/temp05.dbf'
 size4g
 autoextendon
 next128m;




-- 重建临时表空间
--启动数据库
startup
--创建中转临时表空间
create temporary tablespace temp2 tempfile '/home2/oracle/oradata/sysmon/temp02.dbf' 
  size 512m reuse autoextend on next 640k maxsize unlimited;

--改变缺省临时表空间 为刚刚创建的新临时表空间temp2
alter database default temporary tablespace temp2;

--删除原来临时表空间
drop tablespace temp including contents and datafiles;

--重新创建临时表空间
create temporary tablespace temp tempfile '/home2/oracle/oradata/sysmon/temp01.dbf' 
  size 512m reuse autoextend on next 640k maxsize unlimited;

--重置缺省临时表空间为新建的temp表空间
alter database default temporary tablespace temp;

--删除中转用临时表空间
drop tablespace temp2 including contents and datafiles;

--重新指定用户表空间为重建的临时表空间
alter user roll temporary tablespace temp;




-- 查询所有用户
select * from dba_users

-- 查询状态为open的用户
select * from dba_users where account_status='open'



--查询哪个用户对应的表空间的路径
select t.tablespace_name, t.file_name, t.bytes / 1024 / 1024 / 1024
  from dba_data_files t
 where t.tablespace_name = 'users';

select t.tablespace_name, t.file_name, t.bytes / 1024 / 1024 / 1024
  from dba_data_files t
 where t.tablespace_name = 'ts_aj_data';


-- 24.修改表名 重命名表名
alter table controls rename to rmp_controls

alter table sellers_rights rename to rmp_sellers_rights

alter table rmp_sellers_rights rename to rmp_permit_rights

alter table scott.test rename to test1--修改表名

--重命名表名
alter table rmp_tbs_info rename to rmp_tbs_info_tmp

-- 25.添加表字段，修改表字段，删除表字段
--这里要注意几个地方，首先，增加和修改列是不需要加关键字column，否则会报错ora-00905。
--其次，对删除单列的话，一定要加column，然后记住，删除是不需要加列类型的。

-- 添加多列
-- 添加表字段
alter table tablename add (column datatype [default value][null/not null],….);
alter table tablename add (column1   varchar2(20),column2   number(7,2)...)

--增加多列  增加列
alter table reward_scheme add (stockid number(18),stockname varchar2(100))

alter table cpms_card add (parentcardcode varchar2(50));


-- 添加表列
alter table scott.test add address varchar2(40)

alter table rmp_tbs_info add print_date date;

--增加一列
alter table reward_scheme add test_id varchar2(10);

--添加主键
alter table rmp_tbs_info add constraint pk_tbs_cell_id primary key (cell_id)

--给列添加外键
alter table table_aaa add constraint fk_table_aaa_r_table_bbb_s 
foreign key (stockman) references table_bbb (id)


-- 修改表字段
alter table tablename modify (column datatype [default value][null/not null],….);

--修改多列
alter table reward_scheme modify (test_id number(20),test_name varchar2(50));

alter table cpms_card modify(operateuserid number(32),operateusername nvarchar2(100),operatetime date);

alter table base_log modify id long;

alter table rmp_tbs_info modify (coverage number(5,2))

alter table scott.test modify name1 number(20) --修改字段类型

--修改一列
alter table reward_scheme modify test_id varchar2(20);

-- 修改列名
alter table [table_name] rename column [column_name] to [new_column_name];

alter table scott.test rename column name to name1 --修改表列名

--修改列名
alter table reward_record rename column reward_object_id to reward_object

--修改列名
alter table reward_scheme rename column mark to remark

--重命名列名
alter table rmp_tbs_info rename column report_doctor to report_doctor_name

--删除表列 删除表字段
alter table tablename drop (column);

--删除多列
alter table reward_scheme drop (test_id,test_name);

--删除列
alter table reward_scheme drop column 列名

--删除一列
alter table reward_scheme drop column test_id;

alter table scott.test drop name cascadeconstraints --删除表列

alter table rmp_tbs_info drop(report_doctor_id)

-- 删除字段
-- alter table [schema_name.]table_name drop column column_name1[|column_name2] [cascade constraint]

alter table qq drop column aaa
-- (注意time为字段名，要大写)
alter table qq set unused ("aaa" cascade constraints;




--删除表中已有的主键
alter table rmp_tbs_info drop constraint pk_cell_id

-- 26.添加表描述，添加字段描述，修改字段描述，删除字段描述
comment on column table_aaa.stockman is '管理人员' --给列添加注释


-- 27.常用语句switch


-- 28.查询会话
select sid, program, serial#, username from v$session;

-- 查询是否有锁定表的会话
select sid, serial#, username, osuser from v$session where sid 
in(select session_id from v$locked_object);

--超级管理员下执行干掉其它连接用户
select sid,serial#,username,machine from v$session where username is not null;
--35    45    hr    lx-think
alter system kill session '35,45';--可以干掉hr的连接

select name,value from v$sga;

-- 29.开启限制会话模式
-- 维护数据库的时候开启限制会话模式
alter system enable restricted session;

--restricted模式以后  除了管理员都不能登录，如果需要非管理员登录，必须
grant restricted session to test；

-- 取消限制会话模式
-- 数据库维护完毕之后取消限制会话模式
alter system disable restricted session;


-- 查看oracle版本号 查看版本号 查看数据库版本和位数 多少位
select * from v$version

select sid,serial#,username,program,machine,status
from v$session;

select count(*) from v$session   --#连接数

select count(*) from v$session   --#连接数

select count(*) from v$session where status='active' ; --#并发连接数


select * from v$session 
where username is not null 
--and username='tocall'
order by logon_time desc,sid desc;



select * from v$session;

show parameter processes   --#最大连接

alter system set processes = value scope = spfile;  --重启数据库   #修改连接

select version from v$instance;

select username,count(username) from v$session where username is not null group by username

select count(*) from v$process

select value from v$parameter where name = 'processes'

select version from product_component_version where lower(substr(product,1,6)) = 'oracle' 

select * from product_component_version where lower(substr(product,1,6)) = 'oracle'; 

-- sql> set serveroutput on 
-- sql> exec dbms_output.put_line( dbms_db_version.version );  


--查看版本
select * from v$version

32位：输出为8位16进制数
select address from v$sql where rownum<2;
--b50accac

64位：输出为16位16进制数
select address from v$sql where rownum<2;
--0000000196fdf7d8

--如果输出为8位16进制数，则为32位oracle
--如果输出为16位16进制数，则为64位oracle
select address  from v$sql where rownum<2


--pl/sql中存在以bin开头的垃圾表
-- 这个是表drop table后存在于回收站中的垃圾表
-- 使用purge recyclebin 清空回收站中的垃圾表

-- 查询所有此类表
select * from recyclebin where type='table';
-- 删除回收站中所有的表
purge recyclebin;  


-- 删除指定的表
purge table table_name;  

-- 闪回被删除的表
flashback table table_name to before drop; 


-- 可以在的drop表时不产生bin型表
drop table table_name purge；

-- 可以在的drop表时不产生bin型表
drop table "tablename" purge；

-- 设置falshback功能的开启和关闭
sql>startup mount
sql>alter database flashback on(off)


--查询数据库资源是否释放
select t2.username,t2.sid,t2.serial#,t2.logon_time from v$locked_object t1,v$session t2 where t1.session_id=t2.sid;


--释放资源解锁
alter system kill session 'sid, serial#'
alter system kill session '136, 3660';

alter system kill session '76, 443';




-- 查看占用系统io较大的session 
select se.sid, 
       se.serial#, 
       pr.spid, 
       se.username, 
       se.status, 
       se.terminal, 
       se.program, 
       se.module, 
       se.sql_address, 
       st.event, 
       st.p1text, 
       si.physical_reads, 
       si.block_changes 
  from v$session se, 　v$session_wait st, v$sess_io si, v$process pr 
where st.sid = se.sid 　and st.sid = si.sid 
   and se.paddr = pr.addr 
   and se.sid > 6　and st.wait_time = 0 
   and st.event not like '%sql%' 
order by physical_reads desc


-- 找出耗cpu较多的session 
select sys.v_$session.osuser,sys.v_$session.machine,v$lock.sid, 
　　sys.v_$session.serial#, 
　　decode(v$lock.type, 
　　'mr', 'media recovery', 
　　'rt','redo thread', 
　　'un','user name', 
　　'tx', 'transaction', 
　　'tm', 'dml', 
　　'ul', 'pl/sql user lock', 
　　'dx', 'distributed xaction', 
　　'cf', 'control file', 
　　'is', 'instance state', 
　　'fs', 'file set', 
　　'ir', 'instance recovery', 
　　'st', 'disk space transaction', 
　　'ts', 'temp segment', 
　　'iv', 'library cache invalida-tion', 
　　'ls', 'log start or switch', 
　　'rw', 'row wait', 
　　'sq', 'sequence number', 
　　'te', 'extend table', 
　　'tt', 'temp table', 
　　'unknown') locktype, 
　　rtrim(object_type) || ' ' || rtrim(owner) || '.' || object_name object_name, 
　　decode(lmode, 0, 'none', 
　　1, 'null', 
　　2, 'row-s', 
　　3, 'row-x', 
　　4, 'share', 
　　5, 's/row-x', 
　　6, 'exclusive', 'unknown') lockmode, 
　　decode(request, 0, 'none', 
　　1, 'null', 
　　2, 'row-s', 
　　3, 'row-x', 
　　4, 'share', 
　　5, 's/row-x', 
　　6, 'exclusive', 'unknown') requestmode, 
　　ctime, block b 
　　from v$lock, all_objects, sys.v_$session 
　　where v$lock.sid > 6 and sys.v_$session.sid = v$lock.sid 
　　and v$lock.id1 = all_objects.object_id; 



-- oracle中查询被锁的表并释放session 
select a.owner, 
       a.object_name, 
       b.xidusn, 
       b.xidslot, 
       b.xidsqn, 
       b.session_id, 
       b.oracle_username, 
       b.os_user_name, 
       b.process, 
       b.locked_mode, 
       c.machine, 
       c.status, 
       c.server, 
       c.sid, 
       c.serial#, 
       c.program 
  from all_objects a, v$locked_object b, sys.gv_$session c 
where (a.object_id = b.object_id) and (b.process = c.process) 
order by 1, 2 


-- 查询session被锁的sql,简要查询,得到sid 
select object_name,machine,s.sid,s.serial# 
from v$locked_object l,dba_objects o ,v$session s 
where l.object_id　=　o.object_id and l.session_id=s.sid; 


-- 获得进程（线程）号
select spid, osuser, s.program 
from v$session s,v$process p 
where s.paddr=p.addr and s.sid=30; 

-- 查看执行计划情况
select * from table(dbms_xplan.display_cursor('gwp663cqh5qbf',0));

-- 查看锁表情况
select ao.owner,ao.object_name,lo.locked_mode,lo.os_user_name,lo.process,session_id,lo.oracle_username
from v$locked_object lo, dba_objects ao where ao.object_id = lo.object_id


-- oracle杀掉进程
-- 1、进程对应sid,serial#
select sid,serial#,username,schemaname,osuser,machine,program,sql_id, sql_child_number, action
--sql_exec_start
from v$session where machine ='xxx';

-- 2、oracle杀掉
alter system kill session '1089,16019';

-- 3、被标记为killed后，无法kill，在系统找对应进程spid并杀掉:
select spid, osuser, s.program
from v$session s, v$process p
where s.paddr = p.addr and s.sid =1089;


-- 查询是否堵塞
select b.sid,b.serial#,b.process,d.ctime "lock time (sec)",c.object_name,
         decode(a.locked_mode,
             1, 'null',
             2,'row shared',
             3,'row exclusive',
             4,'shared',
             5,'s/row exclusive',
             6, 'exclusive') "lock mode",
      b.last_call_et "inactive for(sec)",
      decode(d.block, 1, 'yes', 0, 'no') "blocking",
      dbms_rowid.rowid_create(1,c.data_object_id,b.row_wait_file#,
       b.row_wait_block#,b.row_wait_row#) "locked rowid"
 from v$locked_object a, v$session b, dba_objects c, v$lock d
 where b.sid = a.session_id
  and c.object_id = a.object_id
  and d.sid = a.session_id
  and d.id1 = a.object_id;




-- 在windows（unix也适用）用orakill杀死线程，orakill是oracle提供的一个可执行命令
orakill sid thread 
-- 其中： 
-- sid：表示要杀死的进程属于的实例名 
-- thread：是要杀掉的线程号，即第3步查询出的spid。 
-- 例：c:>orakill orcl 12345 


--查询spid
 select spid, osuser, s.program from v$session s,v$process p where s.paddr=p.addr and  s.sid=136





-- 连接库的session运行情况
select distinct a.sid,b.serial#,b.process,b.status from v$session_wait a,v$session b
where a.sid=b.sid

--结束进程
orakill orcl spid
c:>orakill orcl 6020






-- 创建job
-- 相关视图
select * from dba_jobs;
select * from all_jobs;
select * from user_jobs;
-- 正在运行job 正在执行的job
select * from dba_jobs_running;

-- 字段（列）          类型                 描述
-- job                number          任务的唯一标示号
-- log_user           varchar2(30)    提交任务的用户
-- priv_user          varchar2(30)    赋予任务权限的用户
-- schema_user        varchar2(30)    对任务作语法分析的用户模式
-- last_date          date            最后一次成功运行任务的时间
-- last_sec           varchar2(8)     如hh24:mm:ss格式的last_date日期的小时，分钟和秒
-- this_date          date            正在运行任务的开始时间，如果没有运行任务则为null
-- this_sec           varchar2(8)     如hh24:mm:ss格式的this_date日期的小时，分钟和秒
-- next_date          date            下一次定时运行任务的时间
-- next_sec           varchar2(8)     如hh24:mm:ss格式的next_date日期的小时，分钟和秒
-- total_time         number          该任务运行所需要的总时间，单位为秒
-- broken             varchar2(1)     标志参数，y标示任务中断，以后不会运行
-- interval           varchar2(200)   用于计算下一运行时间的表达式
-- failures           number     任务运行连续没有成功的次数
-- what               varchar2(2000)  执行任务的pl/sql块
-- current_session_label raw          mlslabel 该任务的信任oracle会话符
-- clearance_hi          raw mlslabel     该任务可信任的oracle最大间隙
-- clearance_lo          raw              mlslabel 该任务可信任的oracle最小间隙
-- nls_env               varchar2(2000)   任务运行的nls会话设置
-- misc_env              raw(32)          任务运行的其他一些会话参数 


-- 描述                              interval参数值 
-- 每天午夜12点                 trunc(sysdate + 1) 
-- 每天早上8点30分             trunc(sysdate + 1) + （8*60+30）/(24*60) 
-- 每星期二中午12点            next_day(trunc(sysdate ), ''tuesday'' ) + 12/24 
-- 每个月第一天的午夜12点        trunc(last_day(sysdate ) + 1) 
-- 每个季度最后一天的晚上11点    trunc(add_months(sysdate + 2/24, 3 ), 'q' ) -1/24 
-- 每星期六和日早上6点10分  trunc(least(next_day(sysdate, ''saturday"), next_day(sysdate, "sunday"))) + （6×60+10）/（24×60）

-- 每秒钟执行次

-- interval => sysdate + 1/(24 * 60 * 60)

-- 如果改成sysdate + 10/(24 * 60 * 60)就是10秒钟执行次

-- 每分钟执行 
-- interval => trunc(sysdate,'mi') + 1/ (24*60)

-- 每10分钟执行次
-- trunc(sysdate,'mi') + 10/ (24*60)

-- 每天定时执行 
-- 例如：每天的凌晨1点执行 
-- interval => trunc(sysdate) + 1 +1/ (24)

-- 每周定时执行 
-- 例如：每周一凌晨1点执行 
-- interval => trunc(next_day(sysdate,'星期一'))+1/24

-- 每月定时执行 
-- 例如：每月1日凌晨1点执行 
-- interval =>trunc(last_day(sysdate))+1+1/24

-- 每季度定时执行 
-- 例如每季度的第一天凌晨1点执行 
-- interval => trunc(add_months(sysdate,3),'q') + 1/24

-- 每半年定时执行 
-- 例如：每年7月1日和1月1日凌晨1点 
-- interval => add_months(trunc(sysdate,'yyyy'),6)+1/24

-- 每年定时执行 
-- 例如：每年1月1日凌晨1点执行 
-- interval =>add_months(trunc(sysdate,'yyyy'),12)+1/24


-- begin
--   sys.dbms_job.submit(job => :job,
--                       what => 'pro_add_test;',
--                       next_date => to_date('01-01-4000', 'dd-mm-yyyy'),
--                       interval => 'trunc(sysdate,''mi'')+1/(24*60)');
--   sys.dbms_job.broken(job => :job,
--                       broken => true,
--                       next_date => to_date('01-01-4000', 'dd-mm-yyyy'));
--   commit;
-- end;


-- 创建job
declare
  job number;
begin
  sys.dbms_job.submit(job=>:job,
    what=>'pro_name;',
    next_date=>to_date('22-11-2013 09:09:41', 'dd-mm-yyyy hh24:mi:ss'),
    interval=>'sysdate+1/86400' --每天86400秒钟，即一秒钟运行prc_name过程一次
    );
  commit;
end;

/*
使用dbms_job.submit方法过程，这个过程有五个参数：job、what、next_date、interval与no_parse。

dbms_job.submit( 
job       out binary_ineger, 
what      in  varchar2, 
next_date in  date, 
interval  in  varchar2, 
no_parse  in  booean:=false)

job参数是输出参数，由submit()过程返回的binary_ineger，这个值用来唯一标识一个工作。
一般定义一个变量接收，可以去user_jobs视图查询job值。 
what参数是将被执行的pl/sql代码块，存储过程名称等。 
next_date参数指识何时将运行这个工作。 
interval参数何时这个工作将被重执行。 
no_parse参数指示此工作在提交时或执行时是否应进行语法分析——true，
默认值false。指示此pl/sql代码在它第一次执行时应进行语法分析，
而false指示本pl/sql代码应立即进行语法分析。
*/

-- 在dbms_job这个package中还有其他的过程：broken、change、interval、isubmit、next_date、
-- remove、run、submit、user_export、what；


-- 1、broken()过程更新一个已提交的工作的状态，典型地是用来把一个已破工作标记为未破工作。这个过程有三个参数：job 、broken与next_date。 
-- procedure broken ( 
--   job in binary_integer, 
--   broken in boolean, 
--   next_date in date := sysdate 
-- ) 
-- job参数是工作号，它在问题中唯一标识工作。 
-- broken参数指示此工作是否将标记为破——true说明此工作将标记为破，而false说明此工作将标记为未破。 
-- next_date参数指示在什么时候此工作将再次运行。此参数缺省值为当前日期和时间。

-- job如果由于某种原因未能成功执行，oracle将重试16次后，还未能成功执行，将被标记为broken，重新启动状态为broken的job，有如下两种方式; 
-- a、利用dbms_job.run()立即执行该job 
-- begin 
--   dbms_job.run(:job) --该job为submit过程提交时返回的job number或是去dba_jobs去查找对应job的编号 
-- end;

-- b、利用dbms_job.broken()重新将broken标记为false 
-- begin 
--   dbms_job.broken (:job, false, next_date) 
-- end;

-- 2、change()过程用来改变指定job的设置。 
-- 这个过程有四个参数：job、what 、next_date、interval。 
-- procedure change ( 
--     job in binary_integer, 
--     what in varchar2, 
--     next_date in date, 
--     interval in varchar2 
-- ) 
-- 此job参数是一个整数值，它唯一标识此工作。 
-- what参数是由此job运行的一块pl/sql代码块。 
-- next_date参数指示何时此job将被执行。 
-- interval参数指示一个job重执行的频度。

-- 3、interval()过程用来显式地设置重复执行一个job之间的时间间隔数。 
-- 这个过程有两个参数：job、interval。 
-- procedure interval( 
--     job in binary_integer, 
--     interval in varchar2 
-- ) 
-- job参数标识一个特定的工作。 
-- interval参数指示一个工作重执行的频度。

-- 4、isubmit()过程用来用特定的job号提交一个job。 
-- 这个过程有五个参数：job、what、next_date、interval、no_parse。 
-- procedure isubmit ( 
--     job in binary_ineger, 
--     what in varchar2, 
--     next_date in date, 
--     interval in varchar2, 
--     no_parse in booean := false 
-- ) 
-- 这个过程与submit()过程的唯一区别在于此job参数作为in型参数传递且包括一个由开发者提供的job号。
-- 如果提供的job号已被使用，将产生一个错误。

-- 5、next_date()过程用来显式地设定一个job的执行时间。这个过程接收两个参数：job、next_date。 
-- procedure next_date( 
--     job in binary_ineger, 
--     next_date in date 
-- ) 
-- job标识一个已存在的工作。 
-- next_date参数指示了此job应被执行的日期、时间。

-- 6、remove()过程来删除一个已计划运行的job。这个过程接收一个参数： 
-- procedure remove(job in binary_ineger); 
-- job参数唯一地标识一个工作这个参数的值是由为此工作调用submit()过程返回的job参数的值，已正在运行的job不能删除。

-- 7、run()过程用来立即执行一个指定的job。这个过程只接收一个参数： 
-- procedure run(job in binary_ineger) 
-- job参数标识将被立即执行的工作。

-- 8、使用submit()过程，job被正常地计划。上面以讲述

-- 9、user_export()过程返回一个命令，此命令用来安排一个存在的job以便此job能重新提交。此程序有两个参数：job、my_call。 
-- procedure user_export( 
--     job in binary_ineger, 
--     my_call in out varchar2 
-- ) 
-- job参数标识一个安排了的工作。 
-- my_call参数包含在它的当前状态重新提交此job所需要的正文。

-- 10、what()过程应许在job执行时重新设置此正在运行的命令。这个过程接收两个参数：job、what。 
-- procedure what ( 
--     job in binary_ineger, 
--     what in out varchar2 
-- ) 
-- job参数标识一个存在的工作。 
-- what参数指示将被执行的新的pl/sql代码。实现的功能：每隔一分钟自动向getsysdate表中插入当前的系统时间。


-- 示例
/* 每10秒钟执行一次 插入一条时间 */
 
-- 创建table
create table tab_time(
  currenttime timestamp       
);
 
-- 创建存储过程
create or replace procedure pro_time
as
   begin
       insert into tab_time values(sysdate);
   end;
   
-- 调用过程测试   
begin
   pro_time;   
end;
 
-- 创建job
declare      
   my_job number;
begin
   dbms_job.submit(my_job, 'pro_time;', sysdate, 'sysdate+10/24*60*60');--每10s插入一条记录
end;


查询生成的job id
sql> select job, what from dba_jobs;

job         what

61          .......

 
 
-- 运行job
begin
   dbms_job.run(61);
end; 


-- 查询该job下次执行的时间
 select job,next_date,what from dba_jobs

 where job='61';

 
-- 查询是否插入数据
select to_char(current_time, 'dd-mm-yyyy hh24:mi:ss') current_time from tab_time order by current_time;
 
-- 删除一个job
begin
   dbms_job.remove(61);
end;   



-- 关于设置job任务数量和控制并发
-- 初始化相关参数job_queue_processes 
-- alter system set job_queue_processes = 39 scope = spfile;--最大值不能超过1000; 
-- job_queue_interval = 10; --调度作业刷新频率秒为单位

-- job_queue_process 表示oracle能够并发的job的数量，sqlplus中可以通过语句 
-- show parameter job_queue_process; 来查看oracle中job_queue_process的值。

-- select * from v$parameter;

-- select name, description from v$bgprocess;

-- 当job_queue_process值为0时表示全部停止oracle的job，可以通过语句 
-- alter system set job_queue_processes = 10; 
-- 来调整启动oracle的job。

-- 如果将job_queue_processes 的值设置为1的话，那就是串行运行，即快速切换执行一个job任务。


-- job不运行的大概原因
-- (1)、上面讲解了job的参数：与job相关的参数一个是job_queue_processes，这个是运行job时候所起的进程数，
-- 当然系统里面job大于这个数值后，就会有排队等候的，最小值是0，表示不运行job，最大值是1000，在os上对应的进程时snpn，
-- 9i以后os上管理job的进程叫cjqn。可以使用下面这个sql确定目前有几个snp/cjq在运行。 
-- select * from v$bgprocess，这个paddr不为空的snp/cjq进程就是目前空闲的进程，有的表示正在工作的进程。 
-- 另外一个是job_queue_interval，范围在1--3600之间，单位是秒，这个是唤醒job的process，因为每次snp运行完他就休息了，
-- 需要定期唤醒他，这个值不能太小，太小会影响数据库的性能。

-- 先确定上面这两个参数设置是否正确，特别是第一个参数，设置为0了，所有job就不会自动运行了。

-- (2)、使用下面的sql查看job的的broken，last_date和next_date，last_date是指最近一次job运行成功的结束时间，next_date是
-- 根据设置的频率计算的下次执行时间，根据这个信息就可以判断job上次是否正常，还可以判断下次的时间对不对，sql如下： 
-- select * from dba_jobs; 
-- 有时候我们发现他的next_date是4000年1月1日，说明job要不就是在running，要不就是状态是break(broken=y)，如果发现job的
-- broken值为y，找用户了解一下，确定该job是否可以broken，如果不能broken，那就把broken值修改成n，修改再使用上面的sql查看
-- 就发现它的last_date已经变了，job即可正常运行，修改broken状态的sql如下：

-- begin 
--     dbms_job.broken(<job_id>, false); 
-- end;

-- (3)、使用下面的sql查询是否job还在running 
-- select * from dba_jobs_running; 
-- 如果发现job已经run了很久了还没有结束，就要查原因了。一般的job running时会锁定相关的相关的资源，可以查看一下v$access和
-- v$locked_object这两个view。如果发现其他进程锁定了与job相关的object，包括package/function/procedure/table等资源，
-- 那么就要把其他进程删除，有必要的话，把job的进程也删除，再重新执行看看结果。

-- (4)、如果上面都正常，但是job还不run，怎么办？那我们要考虑把job进程重启一次，防止是snp进程死了造成job不跑，指令如下： 
-- alter system set job_queue_processes = 0; --关闭job进程，等待5--10秒钟 
-- alter system set job_quene_processes = 5; --恢复原来的值

-- (5)、oracle的bug：oracle9i里面有一个bug，当计数器到497天时，刚好达到它的最大值，再计数就会变成-1，继续计数就变成0了，
-- 然后计数器将不再跑了。如果碰到这种情况就得重启数据库，但是其他的oracle7345和oracle8i的数据库没有发现这个问题。

-- (6)、数据库上的检查基本上就这多，如果job运行还有问题，那需要看一下是否是程序本身的问题，比如处理的资料量大，
-- 或者网络速度慢等造成运行时过长，那就需要具体情况具体分析了。我们可以通过下面的sql手工执行一下job看看： 

-- begin 
--       dbms_job.run(<job>_id) 
-- end; 
-- 如果发现job执行不正常，就要结合程序具体分析一下。



/*创建并运行job实例*/

--创建存储过程
create or replace procedure pro_add_test as
begin
  insert into cpms_test(a,b) values(1,1);
  commit;
end;

--创建存储过程job  方便调用
create or replace procedure pro_test_job
as
  job number;
begin
  dbms_job.submit(
    job => job,  /*自动生成job_id*/ 
    what => 'pro_add_test;',  /*需要执行的存储过程名称或sql语句*/ 
    next_date => sysdate + 3/(24*60),  /*初次执行时间-下一个3分钟*/ 
    interval => 'trunc(sysdate,''mi'')+1/(24*60)'  /*每隔1分钟执行一次*/
  );
  commit;
end;

--创建job
declare
  job number;
begin
  dbms_job.submit(
    job => job,  /*自动生成job_id*/ 
    what => 'pro_add_test;',  /*需要执行的存储过程名称或sql语句*/ 
    next_date => sysdate + 3/(24*60),  /*初次执行时间-下一个3分钟*/ 
    interval => 'trunc(sysdate,''mi'')+1/(24*60)'  /*每隔1分钟执行一次*/
  );
  commit;
end;

--手动sql调用job
begin
  dbms_job.run(21);
end;

--删除任务
begin
  /*删除自动执行的job*/
  dbms_job.remove(21);
end;

--停止job
/*停止一个job,里面参数true也可是false，next_date（某一时刻停止）也可是sysdate（立刻停止）。   */
begin
  dbms_job.broken(21, true, sysdate);
end;

--修改job时间
begin
  dbms_job.interval(21, 'trunc(sysdate) + 1');
end;

--修改下次执行时间
begin
  dbms_job.next_date(21, sysdate + 60/(24*60));
end;

--修改要执行的操作
begin
  dbms_job.what（21，'pro_add_test;'）；  --修改某个job名
end;


select * from cpms_test;
--truncate table cpms_test;




--select to_char(systimestamp,'yyyymmdd hh:mi:ss') from dual;

--select * from product_component_version where lower(substr(product,1,6)) = 'oracle'; 

--select * from db001_owner.xods_bosdb_item@dblinktodsj






--多字段查询重复记录
select * from temp_cardconsumptionday a
where (cardcode,quantity,price,total,consumptiondate) in (
select cardcode,quantity,price,total,consumptiondate from temp_cardconsumptionday t
group by cardcode,quantity,price,total,consumptiondate
having count(*) > 1
)
order by cardcode,quantity,price,total,consumptiondate desc




-- 1、查找表中多余的重复记录，重复记录是根据单个字段（peopleid）来判断
select * from people
where peopleid in (select   peopleid from   people group by   peopleid having count

(peopleid) > 1)

-- 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleid）来判断，只留有rowid最小的记录
delete from people 
where peopleid in (select   peopleid from people group by   peopleid   having count

(peopleid) > 1)
and rowid not in (select min(rowid) from   people group by peopleid having count(peopleid

)>1)

-- 3、查找表中多余的重复记录（多个字段） 
select * from vitae a
where (a.peopleid,a.seq) in   (select peopleid,seq from vitae group by peopleid,seq having

count(*) > 1)

-- 4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录
delete from vitae a
where (a.peopleid,a.seq) in   (select peopleid,seq from vitae group by peopleid,seq having

count(*) > 1)
and rowid not in (select min(rowid) from vitae group by peopleid,seq having count(*)>1)

-- 5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录
select * from vitae a
where (a.peopleid,a.seq) in   (select peopleid,seq from vitae group by peopleid,seq having

count(*) > 1)
and rowid not in (select min(rowid) from vitae group by peopleid,seq having count(*)>1)



-- nvl2(expr1,expr2,expr3)
-- 在nvl2中，expr1永远不会被返回，返回值是expr2或expr3。如果expr1不为null，则nvl2返回expr2。如果expr1为null，则nvl2返回expr3




-- trunc()：类似截取函数，按指定的格式截取输入的数据。
-- 1.【trunc(for dates)】trunc()函数处理日期
-- 语法格式：trunc（date[,fmt]）
-- 其中：date 一个日期值；fmt 日期格式。
-- 该日期将按指定的日期格式截取；忽略它则由最近的日期截取。
-- 示例：

-- select trunc(sysdate) from dual;--2017/2/13,返回当前时间
-- select trunc(sysdate,'yy') from dual;--2017/1/1,返回当年第一天
-- select trunc(sysdate,'mm') from dual;--2017/2/1,返回当月的第一天
-- select trunc(sysdate,'d') from dual;--2017/2/12,返回当前星期的第一天，即星期天
-- select trunc(sysdate,'dd') from dual;--2017/2/13,返回当前日期,今天是2017/2/13
-- select trunc(sysdate ,'hh24') from dual;--2017/2/13 15:00:00,返回本小时的开始时间
-- select trunc(sysdate ,'mi') from dual;--2017/2/13 15:13:00,返回本分钟的开始时间
-- trunc(sysdate,'cc')   取当世纪的第一天     to_char(sysdate,'cc')   取当世纪数值
-- trunc(sysdate,'yyyy') 取当年的第一天       to_char(sysdate,'yyyy') 取当年数值
-- trunc(sysdate,'iyyy') 取上年的最后一天     to_char(sysdate,'iyyy') 取当年数值
-- trunc(sysdate,'q')    取当季第一天         to_char(sysdate,'iyyy') 取当季数值
-- trunc(sysdate,'mm')   取当月第一天         to_char(sysdate,'mm')   取当月数值
-- trunc(sysdate,'ww')   取当周第一天(周二)   to_char(sysdate,'ww')   取当周数值(第几周)
-- trunc(sysdate,'iw')   取当周第一天(周一)   to_char(sysdate,'iw')   取当周数值(第几周)

-- trunc(sysdate) - 1  --这是前一天的00点00分00秒
-- trunc(sysdate) - 1/86400; --(24*60*60)这是当天的23点59分59秒  


--当天00:00:00
--今天凌晨00:00:00
select trunc(sysdate) from dual;
select trunc(sysdate) from dual;
 
--当天23:59:59(在当天0时0分0秒的基础上加1天后再减1秒)
select trunc(sysdate) + 1 -1/86400 from dual;
 
--当前日期是一个星期中的第几天,注意：星期日是第一天
select to_char(sysdate,'d'),to_char(sysdate,'day') from dual;

--当前时间(时分秒)
select sysdate from dual;

--明天的这个时间（时分秒）
select sysdate + 1 from dual;

--明天的凌晨00:00:00，即明天的凌晨
select trunc(sysdate) + 1 from dual;

--今天凌晨1点
select trunc(sysdate) + 1/24 from dual;

--明天凌晨1点
select trunc(sysdate) + 1 + 1/24 from dual;

--今天凌晨00:01:00
select trunc(sysdate) + 1/(24*60) from dual;

--今天凌晨00:10:00
select trunc(sysdate) + 10/(24*60) from dual;

--明天凌晨00:01:00
select trunc(sysdate) + 1 + 1/(24*60) from dual;

--今天凌晨00:00:01
select trunc(sysdate) + 1/(24*60*60) from dual;

--明天凌晨00:00:01
select trunc(sysdate) + 1 + 1/(24*60*60) from dual;

-- 当前月下一月一号凌晨4点10分30秒
select add_months(trunc(sysdate, 'mm'), 1) + 4 / 24 + 10/(24*60) + 30/(24*60*60)from dual;

--当前10分钟之后的时间
select trunc(sysdate, 'mi') + 10/(24*60) from dual;

--明天这个时间10分钟之后的时间
select trunc(sysdate, 'mi') + 1 + 10/(24*60) from dual;

--当前10分钟之前的时间
select trunc(sysdate, 'mi') - 10/(24*60) from dual;

--明天这个时间10分钟之前的时间
select trunc(sysdate, 'mi') + 1 - 10/(24*60) from dual;

-- 字符串转日期
select to_date('2019/1/1 00:00:00', 'yyyy/mm/dd hh24:mi:ss') from dual;

-- 本年第一个月,本年第一个月的下一个月，当月的下一月
select trunc(sysdate, 'yy'), add_months(trunc(sysdate, 'yy'), 1), add_months(trunc(sysdate, 'mm'), 1) from dual;


-- 上一年第一天00:00:00
select add_months(trunc(sysdate,'yyyy'), -12) from dual;

-- 上一年第一天23:59:59
select add_months(trunc(sysdate,'yyyy'), -12) + 1 - 1/(24*60*60) from dual;


--上一年（最后一天）的时间00:00:00
select trunc(sysdate, 'i') from dual;
select trunc(sysdate, 'iy') from dual;
select trunc(sysdate, 'iyy') from dual;
select trunc(sysdate, 'iyyy') from dual;

--上一年（最后一天）的时间23:59:59
select trunc(sysdate, 'i') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iy') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iyy') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iyyy') + 1 - 1/(24*60*60) from dual;

--上一年（最后一天）的时间00:00:00
select trunc(sysdate, 'y') - 1 from dual;
select trunc(sysdate, 'yy') - 1 from dual;
select trunc(sysdate, 'yyy') - 1 from dual;
select trunc(sysdate, 'yyyy') - 1 from dual;

--上一年（最后一天）的时间23:59:59
select trunc(sysdate, 'y') - 1/(24*60*60) from dual;
select trunc(sysdate, 'yy') - 1/(24*60*60) from dual;
select trunc(sysdate, 'yyy') - 1/(24*60*60) from dual;
select trunc(sysdate, 'yyyy') - 1/(24*60*60) from dual;



-- 下一年第一天00:00:00
select add_months(trunc(sysdate,'yyyy'), 12) from dual;

-- 下一年第一天23:59:59
select add_months(trunc(sysdate,'yyyy'), 12) + 1 - 1/(24*60*60) from dual;


-- 当前年的年份
select extract(year from sysdate) from dual;
select to_number(to_char(sysdate,'yyyy')) from dual;

--当年第一天的时间00:00:00
select trunc(sysdate, 'y') from dual;
select trunc(sysdate, 'yy') from dual;
select trunc(sysdate, 'yyy') from dual;
select trunc(sysdate, 'yyyy') from dual;
select trunc(sysdate, 'i') + 1 from dual;
select trunc(sysdate, 'iy') + 1 from dual;
select trunc(sysdate, 'iyy') + 1 from dual;
select trunc(sysdate, 'iyyy') + 1 from dual;

--当年第一天的时间23:59:59
select trunc(sysdate, 'y') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'yy') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'yyy') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'yyyy') + 1 - 1/(24*60*60) from dual;
select trunc(sysdate, 'i') + 2 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iy') + 2 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iyy') + 2 - 1/(24*60*60) from dual;
select trunc(sysdate, 'iyyy') + 2 - 1/(24*60*60) from dual;


-- 当年最后一天00:00:00
select add_months(trunc(sysdate, 'yy'), 12) - 1 from dual;

-- 当年最后一天23:59:59
select add_months(trunc(sysdate, 'yy'), 12) - 1/(24*60*60) from dual;


-- add_months()函数 参数 负数 代表 往前  正数 代表 往后
--根据输入的参数，得到某年的最后一天00:00:00
select add_months(trunc(to_date(2019, 'yyyy'), 'yy'), 12) - 1 from dual;

--根据输入的参数，得到某年的最后一天23:59:59
select add_months(trunc(to_date(2019, 'yyyy'), 'yy'), 12) - 1/(24*60*60) from dual;

-- 当月
-- 当前月份
-- 本年到当月的月数
select extract(month from sysdate) from dual;

-- 当月第一天00:00:00
select trunc(sysdate, 'mm') from dual;
-- 当月第一天00:00:00
select trunc(sysdate, 'month') from dual;
-- 当月第一天23:59:59
select trunc(sysdate, 'mm') + 1 - 1/86400 from dual;


-- 当月最后一天00:00:00
select trunc(last_day(sysdate)) from dual;
-- 当月最后一天的00:00:00
select last_day(trunc(sysdate, 'month')) + 1/86400 from dual;
-- 当月最后一天23:59:59
select last_day(trunc(sysdate, 'month')) + 1 - 1 / 86400 from dual;

-- 当前第一天00:00:00和最后一天00:00:00
select trunc(sysdate, 'mm'),last_day(trunc(sysdate)) from dual;

-- 上一月年月
select to_char(add_months(trunc(sysdate), -1), 'yyyymm') from dual;
-- 下一月年月
select to_char(add_months(trunc(sysdate), 1), 'yyyymm') from dual;


-- 上一月第一天00:00:00
select trunc(trunc(sysdate, 'month') - 1, 'month') from dual;
select add_months(trunc(sysdate), -1) from dual;
-- 上一月第一天23:59:59


-- 上一月最后一天00:00:00
select trunc(sysdate, 'mm') - 1 from dual;
-- 上一月最后一天23:59:59
select trunc(sysdate, 'month') - 1 / (24*60*60) from dual;  --86400 = 24*60*60


-- 下一月第一天00:00:00
select last_day(trunc(sysdate, 'month')) + 1 from dual;
select add_months(trunc(sysdate), 1) from dual;

-- 下一月第一天23:59:59


-- 下一月最后一天00:00:00


-- 下一月最后一天23:59:59


-- 30天前的00:00:00
select trunc(sysdate - 30) from dual;

-- 30天后的00:00:00
select trunc(sysdate + 30) from dual;



-- 查找月的第一天,最后一天
select 
trunc(trunc(sysdate, 'month') - 1, 'month') first_day_last_month,
trunc(sysdate, 'month') - 1 / 86400 last_day_last_month,
trunc(sysdate, 'month') first_day_cur_month,
last_day(trunc(sysdate, 'month')) + 1 - 1 / 86400 last_day_cur_month
from dual;

-- 当天的号数
-- 当前天的号数
-- 本月到当日的天数
select extract(day from sysdate) from dual;


-- 从指定的日期中截取
select extract(year from sysdate) year from dual; 
select extract(year from t.createtime) year from cpms_cardconsumptionday; 
select extract(year from to_date('2011-05-17', 'yyyy-mm-dd')) year from dual; 
select extract(month from to_date('2011-05-17', 'yyyy-mm-dd')) month from dual;
select extract(day from to_date('2011-05-17', 'yyyy-mm-dd')) day from dual; 


-- 当年第一天00:00:00，当年年中7月1号的时间00:00:00，当年年中在加6下年第一天00:00:00
select trunc(sysdate, 'yy'), add_months(trunc(sysdate, 'yy'), 6),add_months(add_months(trunc(sysdate, 'yy'), 6), 6) from dual;

-- 本世纪第一天
select trunc(sysdate, 'cc') from dual;


-- 显示指定年份的一年中的12个月
select yymm || lpad(rownum, 2, '0') to_day
from dual cross join (
        select '2019' as yymm
        from dual
)b 
connect by level<=to_number(12);


-- 显示当年一年中的12个月
select yymm || lpad(rownum, 2, '0') ym
from dual cross join (
        select extract(year from sysdate) as yymm
        from dual
)b 
connect by level<=to_number(12);


-- 行转列 转成一列，用逗号隔开
select wm_concat(ym) from (
  select yymm || lpad(rownum, 2, '0') ym
  from dual cross join (
          select extract(year from sysdate) as yymm
          from dual
  )b 
  connect by level<=to_number(12)
);

-- 行转列 把逗号换成|
select replace(wm_concat(ym), ',', '|') ym from (
  select yymm || lpad(rownum, 2, '0') ym
  from dual cross join (
          select extract(year from sysdate) as yymm
          from dual
  )b 
  connect by level<=to_number(12)
);


-- oracle 10g 行转列替代方法
select dep,
sum(decode(ym, '201901', total, 0)) as jan,
sum(decode(ym, '201902', total, 0)) as feb,
sum(decode(ym, '201903', total, 0)) as mar,
sum(decode(ym, '201904', total, 0)) as apr,
sum(decode(ym, '201905', total, 0)) as may,
sum(decode(ym, '201906', total, 0)) as jun,
sum(decode(ym, '201907', total, 0)) as jul,
sum(decode(ym, '201908', total, 0)) as aug,
sum(decode(ym, '201909', total, 0)) as sep,
sum(decode(ym, '201910', total, 0)) as oct,
sum(decode(ym, '201911', total, 0)) as nov,
sum(decode(ym, '201912', total, 0)) as dec
from (
  select 'aa' dep, ym, total from (
    select ym, count(*) total from (
      select yymm || lpad(rownum, 2, '0') ym
      from dual cross join (
        select extract(year from sysdate) as yymm
        from dual
      )b 
      connect by level<=to_number(12)
    )
    group by ym
  )
  order by ym
)
group by dep order by 1;

-- 使用rownum实现1到10的序列
select rownum from dual connect by rownum<=10;

-- 使用level实现1到10的序列
select level from dual connect by level<=10;

--查询当前时间往前的12周的开始时间、结束时间、第多少周
select sysdate - (to_number(to_char(sysdate - 1, 'd')) - 1) -
       (rownum - 1) * 7 as startDate,
       sysdate + (7 - to_number(to_char(sysdate - 1, 'd'))) -
       (rownum - 1) * 7 as endDate,
       to_number(to_char(sysdate, 'iw')) - rownum + 1 as weekIndex
  from dual
connect by level<= 12;--将level改成rownum可以实现同样的效果


-- 字符串分割，由一行变为多行
-- 比如说分割01#02#03#04这种有规律的字符串
select REGEXP_SUBSTR('01#02#03#04', '[^#]+', 1, rownum) as newport 
from dual connect by rownum <= REGEXP_COUNT('01#02#03#04', '[^#]+');



-- 连续时间，最近的7天
select Rownum,(trunc(sysdate + Rownum-7,'dd')) past7 from dual connect by rownum <= 7--稍快推荐使用
select Rownum,(trunc(sysdate + Rownum-7,'dd')) past7 from all_objects where rownum<=7--稍慢

-- 最近的24小时
select Rownum,trunc(sysdate,'hh') + rownum / 24 past24 from dual connect by rownum<=24--稍快推荐使用
select Rownum,trunc(sysdate,'hh') + rownum / 24 past24 from all_objects where rownum<=24--稍慢



-- 在oralce中我发现有add_months函数，加天数n可以用如下方法实现,select sysdate+n from dual
-- 在oralce中我发现有add_months函数，加天数n可以用如下方法实现,select sysdate+n from dual
-- sysdate+1 加一天
-- sysdate+1/24 加1小时
-- sysdate+1/(24*60) 加1分钟
-- sysdate+1/(24*60*60) 加1秒钟
-- 类推至毫秒0.001秒


-- 加法 
select sysdate,add_months(sysdate,12) from dual;        --加1年 
select sysdate,add_months(sysdate,1) from dual;        --加1月 
select sysdate,to_char(sysdate+7,'yyyy-mm-dd hh24:mi:ss') from dual;  --加1星期 
select sysdate,to_char(sysdate+1,'yyyy-mm-dd hh24:mi:ss') from dual;  --加1天 
select sysdate,to_char(sysdate+1/24,'yyyy-mm-dd hh24:mi:ss') from dual;  --加1小时 
select sysdate,to_char(sysdate+1/24/60,'yyyy-mm-dd hh24:mi:ss') from dual;  --加1分钟 
select sysdate,to_char(sysdate+1/24/60/60,'yyyy-mm-dd hh24:mi:ss') from dual;  --加1秒 
-- 减法 
select sysdate,add_months(sysdate,-12) from dual;        --减1年 
select sysdate,add_months(sysdate,-1) from dual;        --减1月 
select sysdate,to_char(sysdate-7,'yyyy-mm-dd hh24:mi:ss') from dual;  --减1星期 
select sysdate,to_char(sysdate-1,'yyyy-mm-dd hh24:mi:ss') from dual;  --减1天 
select sysdate,to_char(sysdate-1/24,'yyyy-mm-dd hh24:mi:ss') from dual;  --减1小时 
select sysdate,to_char(sysdate-1/24/60,'yyyy-mm-dd hh24:mi:ss') from dual;  --减1分钟 
select sysdate,to_char(sysdate-1/24/60/60,'yyyy-mm-dd hh24:mi:ss') from dual;  --减1秒












select 'utl_recomp_end: ' || to_char(sysdate, 'hh:mi:ss') from dual;

select to_char(systimestamp,'yyyymmdd hh:mi:ss') from dual;

select to_char(sysdate, 'yyyyMMddHH24miss'), to_char(systimestamp, 'yyyymmddhh24missff2') from dual;
 
--在oracle中如何得到当天月份的第一天和最后一天
select to_char(sysdate,'yyyy-mm')||'-01' firstday,to_char(last_day(sysdate),'yyyy-mm-dd') lastday from dual
--实现当天16点前数据减去昨天16点的，过了16点减去今天16点
select field1, field2 from mytable
where time = decode(sign(sysdate-trunc(sysdate)-16/24), --时间判断
                     -1,trunc(sysdate)-1+16/24, --小于16点取昨天16点
                        trunc(sysdate)+16/24)  --大于16点取当天16点 


-- 2.【trunc(for number)】trunc()函数处理number型数字
-- 语法格式：trunc（number[,decimals]）
-- 其中： number 待做截取处理的数值；decimals 指明需保留小数点后面的位数，可选项，忽略它则截去所有的小数部分。
-- 注意：截取时并不对数据进行四舍五入。
-- 示例：
-- select trunc(123.567,2) from dual;--123.56,将小数点右边指定位数后面的截去;
-- select trunc(123.567,-2) from dual;--100,第二个参数可以为负数，表示将小数点左边指定位数后面的部分截去，即均以0记;
-- select trunc(123.567) from dual;--123,默认截去小数点后面的部分;

-- 1.trunc
select trunc(123.98)from dual;
select trunc(123.123,2)from dual;
select trunc(123.123,-1)from dual;

--Oracle trunc()函数的用法
/**************日期********************/
select trunc(sysdate) from dual  --2015-03-23   今天的日期为2015-03-23
select trunc(sysdate, 'mm') from dual  --2015-03-01    返回当月第一天.
select trunc(sysdate, 'yy') from dual  --2015-01-01     返回当年第一天
select trunc(sysdate, 'dd') from dual  --2015-03-23   返回当前年月日
select trunc(sysdate, 'yyyy') from dual  --2015-01-01  返回当年第一天
select trunc(sysdate, 'd') from dual  -- 2015-03-22(星期天)返回当前星期的第一天
select trunc(sysdate, 'hh') from dual   --2015-03-23 16:00:00  
select trunc(sysdate, 'mi') from dual  --2015-03-23 16:32:00 TRUNC()函数没有秒的精确
/***************数字********************/
/*
TRUNC（number,num_digits）
Number 需要截尾取整的数字。 
Num_digits 用于指定取整精度的数字。Num_digits 的默认值为 0。
TRUNC()函数截取时不进行四舍五入
*/
select trunc(123.458) from dual --123
select trunc(123.458,0) from dual --123
select trunc(123.458,1) from dual --123.4
select trunc(123.458,-1) from dual --120
select trunc(123.458,-4) from dual --0
select trunc(123.458,4) from dual  --123.458
select trunc(123) from dual  --123
select trunc(123,1) from dual --123
select trunc(123,-1) from dual --120


-- 2.round函数(四舍五入）
select round( number, [ decimal_places ] ) from dual

select round(123.456, 0) from dual;          回传 123
select round(123.456, 1) from dual;          回传 123.5
select round(-123.456, 2) from dual;        回传 -123.46

-- 3.ceil和floor函数
-- ceil和floor函数在一些业务数据的时候，有时还是很有用的。
-- ceil(n) 取大于等于数值n的最小整数；
-- floor(n)取小于等于数值n的最大整数；


-- 日期
-- 将date转成timestamp类型
select cast(date1 as timestamp) "date" from t; 
-- 在转换后的时间段尾部有了一段".000000"。这是因为从date转换过来的时候，没有小数秒的信息，
-- 缺省为0。而且显示格式是按照参数nls_timestamp_format定的缺省格式显示

-- timestamp数据的格式化显示和date 数据一样 注：to_char函数支持date和timestamp，但是trunc却不支持timestamp数据类型
-- 表明了在当两个时间的差别极度重要的情况下，使用timestamp数据类型要比date数据类型更确切
select to_char(time1,'mm/dd/yyyy hh24:mi:ss') "date" from date_table
-- 2 date 
-- 3 ------------------- 
-- 4 06/20/2003 16:55:14 
-- 5 06/26/2003 11:16:36

select to_char(time1,'mm/dd/yyyy hh24:mi:ss:ff3') "date" from date_table
-- 3 date 
-- 4 ----------------------- 
-- 5 06/20/2003 16:55:14:000 
-- 6 06/26/2003 11:16:36:000

-- 得到天数、月数、天数、时数、分钟数和秒数就成为用substr函数摘取出数字的事情了
select time1,
       time2,
       substr((time2 - time1), instr((time2 - time1), ' ') + 7, 2) seconds,
       substr((time2 - time1), instr((time2 - time1), ' ') + 4, 2) minutes,
       substr((time2 - time1), instr((time2 - time1), ' ') + 1, 2) hours,
       trunc(to_number(substr((time2 - time1), 1, instr(time2 - time1, ' ')))) days,
       trunc(to_number(substr((time2 - time1), 1, instr(time2 - time1, ' '))) / 7) weeks
  from date_table
  
-- time1                      time2                      seconds minutes hours days weeks 
-- ------------------------- -------------------------- ------- ------- ----- ---- ----- 
-- 06/20/2003:16:55:14:000000 07/08/2003:11:22:57:000000 43      27      18    17   2 
-- 06/26/2003:11:16:36:000000 07/08/2003:11:22:57:000000 21      06      00    12   1

-- 系统日期和时间,返回成date数据类型
select sysdate from dual;

-- 系统日期和时间,返回成timestamp数据类型
select systimestamp from dual;

-- 设置初始化参数fixed_date指定sysdate函数返回一个固定值。这用在测试日期和时间敏感的代码。注意，这个参数对于systimestamp函数无效
alter system set fixed_date = '2003-01-01-10:00:00'; 
-- system altered

select sysdate from dual; 
 -- 5 sysdate 
 -- 6 --------- 
 -- 7 01-jan-03

select systimestamp from dual; 
-- 10 systimestamp 
-- 11 --------------------------------------------------------- 
-- 12 09-jul-03 11.05.02.519000 am -06:00

-- 例如：查看一下当前距离伦敦奥运会开幕还有多长时间：
select to_date('2012-7-28 03:12:00','yyyy-mm-dd hh24:mi:ss')-sysdate from dual
-- 结果是：92.2472685185185天

-- timestamp是date类型的扩展，可以精确到小数秒,可以是0 to9，缺省是６
-- 两个timestamp相减的话，不能直接的得到天数书，而是得到
-- 多少天，多少小时，多少秒等，例如：同样查看一下当前距离伦敦奥运会开幕还有多长时间
select to_timestamp('2012-7-28 03:12:00','yyyy-mm-dd hh24:mi:ss')-systimestamp from dual
-- 结果是：+000000092 05:51:24.032000000，稍加截取，就可以得到92天5小时，51分钟，24秒

-- to_char来转换timestamp——>date
select to_date(to_char(systimestamp,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') from dual

-- date ——>timestamp
select to_timestamp(to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') from dual



-- to_date格式(以时间:2007-11-02   13:45:25为例)
   
-- year:      
-- yy two digits 两位年                显示值:07
-- yyy three digits 三位年                显示值:007
-- yyyy four digits 四位年                显示值:2007
    
-- month:      
-- mm    number     两位月              显示值:11
-- mon    abbreviated 字符集表示          显示值:11月,若是英文版,显示nov     
-- month spelled out 字符集表示          显示值:11月,若是英文版,显示november 
  
-- day:      
-- dd    number         当月第几天        显示值:02
-- ddd    number         当年第几天        显示值:02
-- dy    abbreviated 当周第几天简写    显示值:星期五,若是英文版,显示fri
-- day    spelled out   当周第几天全写    显示值:星期五,若是英文版,显示friday        
-- ddspth spelled out, ordinal twelfth 
     
--       hour:
--       hh    two digits 12小时进制            显示值:01
--       hh24 two digits 24小时进制            显示值:13
      
--       minute:
--       mi    two digits 60进制                显示值:45
      
--       second:
--       ss    two digits 60进制                显示值:25
      
--       其它
--       q     digit         季度                  显示值:4
--       ww    digit         当年第几周            显示值:44
--       w    digit          当月第几周            显示值:1
      
-- 24小时格式下时间范围为： 0:00:00 - 23:59:59....      
-- 12小时格式下时间范围为： 1:00:00 - 12:59:59 .... 
            
-- 1. 日期和字符转换函数用法（to_date,to_char）
         
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') as nowtime from dual;   --日期转化为字符串   
select to_char(sysdate,'yyyy') as nowyear   from dual;   --获取时间的年   
select to_char(sysdate,'mm')    as nowmonth from dual;   --获取时间的月   
select to_char(sysdate,'dd')    as nowday    from dual;   --获取时间的日   
select to_char(sysdate,'hh24') as nowhour   from dual;   --获取时间的时   
select to_char(sysdate,'mi')    as nowminute from dual;   --获取时间的分   
select to_char(sysdate,'ss')    as nowsecond from dual;   --获取时间的秒
    
select to_date('2004-05-07 13:23:44','yyyy-mm-dd hh24:mi:ss')    from dual--

-- 2.      
select to_char( to_date(222,'j'),'jsp') from dual      

-- 显示two hundred twenty-two    

-- 3.求某天是星期几      
select to_char(to_date('2002-08-26','yyyy-mm-dd'),'day') from dual;      
-- 星期一      
select to_char(to_date('2002-08-26','yyyy-mm-dd'),'day','nls_date_language = american') from dual;      
-- monday      
-- 设置日期语言      
-- alter session set nls_date_language='american';      
-- 也可以这样      
-- to_date ('2002-08-26', 'yyyy-mm-dd', 'nls_date_language = american')    

-- 4. 两个日期间的天数      
select floor(sysdate - to_date('20020405','yyyymmdd')) from dual;    

-- 5. 时间为null的用法      
select id, active_date from table1      
union      
select 1, to_date(null) from dual;      

-- 注意要用to_date(null)    

-- 6.月份差   
--    a_date between to_date('20011201','yyyymmdd') and to_date('20011231','yyyymmdd')      
--    那么12月31号中午12点之后和12月1号的12点之前是不包含在这个范围之内的。      
--    所以，当时间需要精确的时候，觉得to_char还是必要的 
  
-- 7. 日期格式冲突问题      
--     输入的格式要看你安装的oracle字符集的类型, 比如: us7ascii, date格式的类型就是: '01-jan-01'      
--     alter system set nls_date_language = american      
--     alter session set nls_date_language = american      
--     或者在to_date中写      
--     select to_char(to_date('2002-08-26','yyyy-mm-dd'),'day','nls_date_language = american') from dual;      
--     注意我这只是举了nls_date_language，当然还有很多，      
--     可查看      
select * from nls_session_parameters      
select * from v$nls_parameters    

-- 8.      
select count(*)      
from ( select rownum-1 rnum      
   from all_objects      
   where rownum <= to_date('2002-02-28','yyyy-mm-dd') - to_date('2002-      
   02-01','yyyy-mm-dd')+1      
  )      
where to_char( to_date('2002-02-01','yyyy-mm-dd')+rnum-1, 'd' )      
    not in ( '1', '7' )      

-- 查找2002-02-28至2002-02-01间除星期一和七的天数      
-- 在前后分别调用dbms_utility.get_time, 让后将结果相减(得到的是1/100秒, 而不是毫秒).    
-- 9. 查找月份     
select months_between(to_date('01-31-1999','mm-dd-yyyy'),to_date('12-31-1998','mm-dd-yyyy')) "months" from dual;
select months_between(to_date('02-01-1999','mm-dd-yyyy'),to_date('12-31-1998','mm-dd-yyyy')) "months" from dual;
1.03225806451613 
   
-- 10. next_day的用法      
next_day(date, day)      

monday-sunday, for format code day      
mon-sun, for format code dy      
1-7, for format code d    
-- 11      
select to_char(sysdate,'hh:mi:ss') time from all_objects      
-- 注意：第一条记录的time 与最后一行是一样的      
-- 可以建立一个函数来处理这个问题      
create or replace function sys_date return date is      
begin      
return sysdate;      
end;      

select to_char(sys_date,'hh:mi:ss') from all_objects;   
 
-- 12.获得小时数      
 -- extract()找出日期或间隔值的字段值
select extract(hour from timestamp '2001-02-16 2:38:40') from offer      
sql> select sysdate ,to_char(sysdate,'hh') from dual;      

sysdate to_char(sysdate,'hh')      
-------------------- ---------------------      
2003-10-13 19:35:21 07      

sql> select sysdate ,to_char(sysdate,'hh24') from dual;      

sysdate to_char(sysdate,'hh24')      
-------------------- -----------------------      
2003-10-13 19:35:21 19    

   
-- 13.年月日的处理      
select older_date,      
   newer_date,      
   years,      
   months,      
   abs(      
    trunc(      
     newer_date-      
     add_months( older_date,years*12+months )      
    )      
   ) days 
   
from ( select      
    trunc(months_between( newer_date, older_date )/12) years,      
    mod(trunc(months_between( newer_date, older_date )),12 ) months,      
    newer_date,      
    older_date      
    from ( 
          select hiredate older_date, add_months(hiredate,rownum)+rownum newer_date      
          from emp 
         )      
  )    

-- 14.处理月份天数不定的办法      
select to_char(add_months(last_day(sysdate) +1, -2), 'yyyymmdd'),last_day(sysdate) from dual    

-- 16.找出今年的天数      
select add_months(trunc(sysdate,'year'), 12) - trunc(sysdate,'year') from dual    

-- 闰年的处理方法      
-- to_char( last_day( to_date('02'    | | :year,'mmyyyy') ), 'dd' )      
-- 如果是28就不是闰年    

-- 17.yyyy与rrrr的区别      
-- yyyy99 to_c      
-- ------- ----      
-- yyyy 99 0099      
-- rrrr 99 1999      
-- yyyy 01 0001      
-- rrrr 01 2001    

-- 18.不同时区的处理      
select to_char( new_time( sysdate, 'gmt','est'), 'dd/mm/yyyy hh:mi:ss') ,sysdate      
from dual;    

-- 19.5秒钟一个间隔      
select to_date(floor(to_char(sysdate,'sssss')/300) * 300,'sssss') ,to_char(sysdate,'sssss')      
from dual    

-- 2002-11-1 9:55:00 35786      
-- sssss表示5位秒数    

-- 20.一年的第几天      
select to_char(sysdate,'ddd'),sysdate from dual
    
310 2002-11-6 10:03:51    
 
-- 21.计算小时,分,秒,毫秒      
select      
 days,      
 a,      
 trunc(a*24) hours,      
 trunc(a*24*60 - 60*trunc(a*24)) minutes,      
 trunc(a*24*60*60 - 60*trunc(a*24*60)) seconds,      
 trunc(a*24*60*60*100 - 100*trunc(a*24*60*60)) mseconds      
from      
(      
 select      
 trunc(sysdate) days,      
 sysdate - trunc(sysdate) a      
 from dual      
)    


select * from tabname      
order by decode(mode,'fifo',1,-1)*to_char(rq,'yyyymmddhh24miss');      

--      
floor((date2-date1) /365) 作为年      
floor((date2-date1, 365) /30) 作为月      
d(mod(date2-date1, 365), 30)作为日.
 
-- 23.next_day函数      返回下个星期的日期,day为1-7或星期日-星期六,1表示星期日
-- next_day(sysdate,6)是从当前开始下一个星期五。后面的数字是从星期日开始算起。      
-- 1 2 3 4 5 6 7      
-- 日 一 二 三 四 五 六    

--------------------------------------------------------------- 

select    (sysdate-to_date('2003-12-03 12:55:45','yyyy-mm-dd hh24:mi:ss'))*24*60*60 from ddual
-- 日期 返回的是天 然后 转换为ss
 
-- 24,round[舍入到最接近的日期](day:舍入到最接近的星期日)
select sysdate s1,
round(sysdate) s2 ,
round(sysdate,'year') year,
round(sysdate,'month') month ,
round(sysdate,'day') day from dual
 
-- 25,trunc[截断到最接近的日期,单位为天] ,返回的是日期类型
select sysdate s1,                     
 trunc(sysdate) s2,                 --返回当前日期,无时分秒
 trunc(sysdate,'year') year,        --返回当前年的1月1日,无时分秒
 trunc(sysdate,'month') month ,     --返回当前月的1日,无时分秒
 trunc(sysdate,'day') day           --返回当前星期的星期天,无时分秒
from dual
 
-- 26,返回日期列表中最晚日期
select greatest('01-1月-04','04-1月-04','10-2月-04') from dual
 
-- 27.计算时间差
-- 注:oracle时间差是以天数为单位,所以换算成年月,日
--时间差-年
select floor(to_number(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))/365) as spanyears from dual
--时间差-月        
select ceil(moths_between(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))) as spanmonths from dual
--时间差-天
select floor(to_number(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))) as spandays from dual    
--时间差-时         
select floor(to_number(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))*24) as spanhours from dual
--时间差-分     
select floor(to_number(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))*24*60) as spanminutes from dual
--时间差-秒
select floor(to_number(sysdate-to_date('2007-11-02 15:55:03','yyyy-mm-dd hh24:mi:ss'))*24*60*60) as spanseconds from dual 

-- 28.更新时间
-- 注:oracle时间加减是以天数为单位,设改变量为n,所以换算成年月,日
--改变时间-年
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(sysdate+n*365,'yyyy-mm-dd hh24:mi:ss') as newtime from dual
--改变时间-月
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),add_months(sysdate,n) as newtime from dual
--改变时间-日
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(sysdate+n,'yyyy-mm-dd hh24:mi:ss') as newtime from dual     
--改变时间-时       
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(sysdate+n/24,'yyyy-mm-dd hh24:mi:ss') as newtime from dual   
--改变时间-分      
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(sysdate+n/24/60,'yyyy-mm-dd hh24:mi:ss') as newtime from dual   
--改变时间-秒   
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),to_char(sysdate+n/24/60/60,'yyyy-mm-dd hh24:mi:ss') as newtime from dual   

-- 29.查找月的第一天,最后一天
select trunc(trunc(sysdate, 'month') - 1, 'month') first_day_last_month,
 trunc(sysdate, 'month') - 1 / 86400 last_day_last_month,
 trunc(sysdate, 'month') first_day_cur_month,
 last_day(trunc(sysdate, 'month')) + 1 - 1 / 86400 last_day_cur_month
from dual;




-- dbms_lob.substr（）转换clob字段为varchar2类型


-- 插入海量数据特别慢的解决方法
-- 问题解决：
-- 查询会话的统计信息，发现redo的产生量非常的大，所以解决办法：

-- 第一步： 将表修改为nologging属性
-- 第二步： 将索引修改为nologging属性
-- 第三步： 插入的时候采用append方式来插入
-- 第四步：如果还是慢点的话，可以采用并行插入，增大排序缓冲区
-- 第五步：如果有可能可以先把索引置于无效状态，然后插入完成之后再重建索引
 -- 以上解决办法
 -- ①必须是该表的数据不重要，不然修改为nologging属性后万一数据丢失可能就找不回来了，
 -- ② 索引一般都为nologging模式，索引记录redo没有作用 
 -- ③ 采用append插入的前提是该表上边没有大量的delete动作


-- 将表及其索引置于nologging模式：
alter table riskrept.base_fmlg nologging;

alter index dx_rko_fmlg_batch_date nologging;

alter index idx_rko_fmlg_acct nologging;

alter index idx_rko_fmlg_card nologging;

alter index idx_rko_fmlg_dt nologging;

alter index idx_rko_fmlg_mer nologging;

-- 修改会话的属性，开启并行插入
alter session set workarea_size_policy=manual;

alter session set sort_area_size=1000000000; 

alter session enable parallel dml;

-- 并行插入
insert /*+parallel(base_fmlg,4) */ 
       /*+append*/
       into 
base_fmlg (batch_date, date_stamp_st, time_stamp_st, org, acct) 
select /*+parallel(b,6)*/
       /*+append*/
       batch_date, date_stamp_st, time_stamp_st, org, acct from temp_fmlg_purge_2 b;


insert /*+parallel(b,4)*/
       /*+append*/
       into 
base_fmlg (batch_date, date_stamp_st, time_stamp_st, org, acct) 
select /*+parallel(b,6)*/
       /*+append*/
       batch_date, date_stamp_st, time_stamp_st, org, acct from temp_fmlg_purge_2 b;


-- 创建表同事插入数据： 
create table emp as select * from scott.emp

-- 1. 复制表结构及其数据：
create table table_name_new as select * from table_name_old

-- 2. 只复制表结构：
create table table_name_new as select * from table_name_old where 1=2;
-- 或者：
create table table_name_new like table_name_old

-- 还原表数据：
insert into emp select * from scott.emp

-- 如果两个表结构一样
insert into table_name_new select * from table_name_old

-- 如果两个表结构不一样
insert into table_name_new(column1,column2...) select column1,column2... from table_name_old


--substr( string, start_position, [ length ] )
select substr('hello world',0,1) from dual
select substr('hello world',1,1) from dual
select substr('hello world',2,1) from dual
select substr('hello world',3,1) from dual
select substr('hello world',-3,1) from dual
select substr('hello world',-3,3) from dual
select substr('hello world',-3,2) from dual
--instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'） 
select instr('abcd','a') from dual　　--返回1
select instr('abcd','c') from dual　　--返回3
select instr('abcd','e') from dual　   --返回0



--1.分页
select * from 
(
  select b.*, rownum rn from 
  (
    select a.*,u.useraccount from 
    (
      select t.*,cust.cuscode,cust.cusname,cust.orgcode,cust.orgname from 
      (
        select acc.id,acc.authuserid,acc.createtime,acc.userid,auth.cardcode,auth.username,
        auth.usercardid,auth.phone,auth.authenddate,auth.customerid 
        from cpms_cardauthaccount acc left join  cpms_cardauthuser auth 
        on acc.authuserid = auth.id where acc.isdelete='0'
      ) t 
      left join 
      cpms_customer cust on t.customerid = cust.id
    ) a 
    left join 
    base_user u on a.userid = u.id 
    where 1=1
    order by a.createtime desc
  ) b
  where rownum <= 10
)
where rn >= 1

--2.分页
select * from 
(
  select b.*, rownum rn from 
  (
    select a.*,u.useraccount from 
    (
      select t.*,cust.cuscode,cust.cusname,cust.orgcode,cust.orgname from 
      (
        select acc.id,acc.authuserid,acc.createtime,acc.userid,auth.cardcode,auth.username,
        auth.usercardid,auth.phone,auth.authenddate,auth.customerid 
        from cpms_cardauthaccount acc left join  cpms_cardauthuser auth 
        on acc.authuserid = auth.id where acc.isdelete='0'
      ) t 
      left join 
      cpms_customer cust on t.customerid = cust.id
    ) a 
    left join 
    base_user u on a.userid = u.id 
    where 1=1
    order by a.createtime desc
  ) b
)
where rn between 6 and 20


-- 日期转数字
select to_number(to_char(sysdate, 'yyyy')) from dual;



-- 备份/导出dmp文件
-- exp yyy/password@orcl file=c:\aaa.dmp tables=(emp,bonus,dept）

-- 1 将数据库test完全导出,用户名system 密码manager 导出到d:\daochu.dmp中
--    exp system/manager@test file=d:\daochu.dmp full=y

-- 2 将数据库中system用户与sys用户的表导出
--    exp system/manager@test file=d:\daochu.dmp owner=(system,sys)


-- 3 将数据库中的表table1 、table2导出
--    exp system/manager@test file=d:\daochu.dmp tables=(table1,table2)


-- 4 将数据库中的表table1中的字段filed1以"00″打头的数据导出
--    exp system/manager@test file=d:\daochu.dmp tables=(table1) query=\" where filed1like &apos;00%&apos;\"

-- 上面是常用的导出，对于压缩我不太在意，用winzip把dmp文件可以很好的压缩。不过在上面命令后面 加上 compress=y   就可以了。


-- 还原/导入dmp文件
-- imp yyy/password@orcl file =c:\users\lenovo\desktop\scoot.dmp full=y ignore=y;
-- 1 将d:\daochu.dmp 中的数据导入 test数据库中。
-- imp system/manager@test   file=d:\daochu.dmp


-- 上面可能有点问题，因为有的表已经存在，然后它就报错，对该表就不进行导入。
-- 在后面加上 ignore=y 就可以了。


-- 2 将d:\daochu.dmp中的表table1 导入
-- imp system/manager@test   file=d:\daochu.dmp   tables=(table1)



/*
基本语法和实例： 
    1、exp: 
      有三种主要的方式（完全、用户、表） 
      1、完全： 
          exp system/manager buffer=64000 file=c:\full.dmp full=y 
          如果要执行完全导出，必须具有特殊的权限 
      2、用户模式： 
          exp sonic/sonic    buffer=64000 file=c:\sonic.dmp owner=sonic 
          这样用户sonic的所有对象被输出到文件中。 
      3、表模式：
          exp sonic/sonic    buffer=64000 file=c:\sonic.dmp owner=sonic tables=(sonic) 
          这样用户sonic的表sonic就被导出 
    2、imp: 
      具有三种模式（完全、用户、表） 
      1、完全： 
          imp system/manager buffer=64000 file=c:\full.dmp full=y 
      2、用户模式： 
          imp sonic/sonic    buffer=64000 file=c:\sonic.dmp fromuser=sonic touser=sonic 
          这样用户sonic的所有对象被导入到文件中。必须指定fromuser、touser参数，这样才能导入数据。 
      3、表模式： 
          exp sonic/sonic    buffer=64000 file=c:\sonic.dmp owner=sonic tables=(sonic) 
          这样用户sonic的表sonic就被导入。

*/


-- oracle11g 导出空表
--对已存在的表 执行如下 ，要经过统计分析后 num_rows=0 才准确
select 'alter table '||table_name||' allocate extent;' from user_tables where num_rows=0 

-- Oracle11g默认对空表不分配segment，故使用exp导出Oracle11g数据库时，空表不会导出。
-- 设置deferred_segment_creation 参数为FALSE后，无论是空表还是非空表，都分配segment。

-- 在sqlplus中，执行如下命令： 
SQL>alter system set deferred_segment_creation=false;
SQL>show parameter deferred_segment_creation;
-- 该值设置后只对后面新增的表产生作用，对之前建立的空表不起作用


-- imp  导入时 要先drop 掉原来的表，再imp 
-- impdp 时 用 table_exists_action=replace  表示表存就删除，再创建  
-- 还有skip 跳过
-- append  追加
-- truncate  先 truncate 然后 再插入数据



-- expdp和impdp数据泵导入导出（大数据量，亿万级）
-- 1.新建逻辑目录
-- 最好以system等管理员创建逻辑目录，oracle不会自动创建实际的物理目录"d:\oracledata"
-- （务必手动创建此目录），仅仅是进行定义逻辑路径dump_dir；
-- 运行cmd；
-- 登录数据库，输入命令：sqlplus；
-- 使用管理员角色登录需要在用户名后加" as sysdba" 例如：sys as sysdba
sql> conn system/123456@orcl as sysdba;
sql>create directory dump_dir as 'e:\ora\data';
-- data_dir为路径名称，可自命名，e:\ora\data为数据库导出文件存放路径（路径必须存在）； 
-- 2.查看管理员目录（同时查看操作系统是否存在该目录，因为oracle并不关心该目录是否存在，假如不存在，则出错）
sql>select * from dba_directories;

-- 为oracle用户授予访问数据目录的权限，输入命令：
grant read,write on directory data_dir to flack;
-- 导入导出操作授权，输入命令：
grant exp_full_database,imp_full_database to flack;
-- 退出，输入命令：exit;


-- 3.用expdp导出数据
-- 数据导出，执行命令：
expdp dbuser/123456@orcl schemas=dbuser dumpfile=expdp.dmp directory=data_dir logfile=expdp.log
-- expdp [为用户名]/[密码]@[服务名] 
-- schemas=[为用户名] 
-- dumpfile=[导出数据库文件（可自命名）] 
-- directory=[目录名] 
-- logfile=[日志文件文件名（可自命名）] 
-- 注意：命令结束不需要加";"！

-- 1)导出用户及其对象
expdp scott/tiger@orcl schemas=scott dumpfile=expdp.dmp directory=dump_dir;

-- 2)导出指定表
expdp scott/tiger@orcl tables=emp,dept dumpfile=expdp.dmp directory=dump_dir;

-- 3)按查询条件导
expdp scott/tiger@orcl directory=dump_dir dumpfile=expdp.dmp tables=empquery='where deptno=20';

-- 4)按表空间导
expdp system/manager@orcl directory=dump_dir dumpfile=tablespace.dmptablespaces=temp,example;

-- 5)导整个数据库
expdp system/manager@orcl directory=dump_dir dumpfile=full.dmp full=y;


-- 数据泵导出 备份文件以日期时间命名
-- 日期格式
expdp system/system@orcl schemas=wxcqhtba directory=DATA_PUMP_DIR 
dumpfile=wxcqhtba_%DATE%.dmp logfile=wxcqhtba_%DATE%.log

-- 日期时间的格式 
expdp system/system@orcl schemas=wyzj directory=DATA_PUMP_DIR 
dumpfile=wyzj_%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%%time:~0,2%%time:~3,2%.dmp 
logfile=wyzj_%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%%time:~0,2%%time:~3,2%.log




-- 4.用impdp导入数据
-- 在正式导入数据前，要先确保要导入的用户已存在，如果没有存在，请先用下述命令进行新建用户

-- 数据导入，执行命令：
impdp user/123456@orcl remap_schema = dbuser:user table_exists_action = replace 
directory=data_dir dumpfile=expdp.dmp logfile=expdp.log
-- impdp [用户名]/[密码]@[服务名] 
-- remap_schema=[源用户名1]:[目标用户名2] 
-- table_exists_action=replace /*存在的表动作(覆盖)*/ 
-- directory=[目录名] 
-- dumpfile=[.dmp文件名] 
-- logfile=[.log文件名] 

-- 从一个用户导入到另一个用户，如果表空间不一样，还要加(remap_tablespace=ha_wxzj_data:users)部分
-- HA_WXZJ 是导出用户的数据  ha_wxzj 是导入用户的数据
-- ha_wxzj_data 导出用户表空间   users 导入用户表空间
impdp system/system@ORCL directory=DATA_PUMP_DIR 
dumpfile=20141218.dmp remap_schema=HA_WXZJ:ha_wxzj remap_tablespace=ha_wxzj_data:users




--创建表空间
create tablespace tb_name datafile 'd:\tablespace\tb_name.dbf' size 1024m autoextend on;
--创建用户
create user flack identified by a123456a default tablespace tb_name temporary tablespace temp;
--给用户授权
sql>grant read,write on directory dump_dir to flack;
sql>grant dba,resource,unlimited tablespace to flack;

-- 1)导入用户（从用户scott导入到用户scott）
impdp scott/tiger@orcl directory=dump_dir dumpfile=expdp.dmp schemas=scott;

-- 2)导入表（从scott用户中把表dept和emp导入到system用户中）
impdp system/manager@orcl directory=dump_dir dumpfile=expdp.dmptables=scott.dept,scott.emp remap_schema=scott:system;

-- 3)导入表空间
impdp system/manager@orcl directory=dump_dir dumpfile=tablespace.dmp tablespaces=example;

-- 4)导入数据库
impdb system/manager@orcl directory=dump_dir dumpfile=full.dmp full=y;

-- 5)追加数据
impdp system/manager@orcl directory=dump_dir dumpfile=expdp.dmp schemas=systemtable_exists_action







-- 检查数据库是否在mts模式下
select distinct server from v$session;
-- 如果返回值出现none或shared，说明启用了mts





-- 锁定账号
-- set verify off
-- set echo on
-- spool d:\app\administrator\admin\bar2008\scripts\lockaccount.log append
-- begin 
--  for item in ( select username from dba_users where account_status in ('open', 'locked', 'expired') and username not in (
-- 'sys','system') ) 
--  loop 
--   dbms_output.put_line('locking and expiring: ' || item.username); 
--   execute immediate 'alter user ' ||
--     sys.dbms_assert.enquote_name(
--     sys.dbms_assert.schema_name(
--     item.username),false) || ' password expire account lock' ;
--  end loop;
-- end;
-- /
-- spool off

-- 查存储过程正在运行的sql运行情况
select a.username,a.machine, b.sql_id, b.sql_text
from v$session a, v$sqlarea b
where a.sql_address = b.address and a.sql_hash_value = b.hash_value;


-- 系统函数
-- oracle提供的系统方法（系统函数）：

-- nvl(expr1, expr2)
-- 第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第一个参数本来的值

-- nvl2(expr1, expr2, expr3)
-- 第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第三个参


-- (1)rank函数返回一个唯一的值，除非遇到相同的数据时，此时所有相同数据的排名是一样的，同时会在最后一条相同记录和下一条不同记录的排名之间空出排名。 
-- (2)dense_rank函数返回一个唯一的值，除非当碰到相同数据时，此时所有相同数据的排名都是一样的。
-- (3)row_number函数返回一个唯一的值，当碰到相同数据时，排名按照记录集中记录的顺序依次递增。
-- (4)ntile是要把查询得到的结果平均分为几组，如果不平均则分给第一组。


-- nullif(exp1,expr2)
-- 如果exp1和exp2相等则返回空(null)，否则返回第一个值

-- coalesce(expr1, expr2, expr3….. exprn)
-- 可以指定多个表达式的占位符。所有表达式必须是相同类型，或者可以隐性转换为相同的类型
-- coalese函数的作用是的nvl的函数有点相似，其优势是有更多的选项
select coalesce(null,null,3,4,5) from dual 　　
-- 其返回结果为：3
-- 如果所有自变量均为 null，则 coalesce 返回 null 值

decode
-- decode(条件,值1,返回值1,值2,返回值2,...值n,返回值n,缺省值)
-- 该函数的含义如下：
/*IF 条件=值1 THEN
　　　　RETURN(翻译值1)
ELSIF 条件=值2 THEN
　　　　RETURN(翻译值2)
　　　　......
ELSIF 条件=值n THEN
　　　　RETURN(翻译值n)
ELSE
　　　　RETURN(缺省值)
END IF*/

-- decode(字段或字段的运算，值1，值2，值3）
-- 这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3
-- 当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多


-- 使用方法：
select  decode(a, b, c, b/a) from dual;
-- 参数意义： 
-- 当a=b时，输出c，否则输出 b/a


/*1、比较大小
select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值
sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1
例如：
变量1=10，变量2=20
则sign(变量1-变量2)返回-1，decode解码结果为"变量1"，达到了取较小值的目的。*/
select decode(sign(10 - 20), -1, 12, 23) from dual;

-- 2、此函数用在SQL语句中，功能介绍如下：
/*Decode 函数与一系列嵌套的 IF-THEN-ELSE语句相似。base_exp与compare1,compare2等等依次进行比较。
如果base_exp和 第i 个compare项匹配，就返回第i 个对应的value 。如果base_exp与任何的compare值都不匹配，则返回default。
每个compare值顺次求值，如果发现一个匹配，则剩下的 compare值（如果还有的话）就都不再求值。
一个为NULL的base_exp被认为和NULL compare值等价。如果需要的话，每一个compare值都被转换成和第一个compare 值相同的数据类型，
这个数据类型也是返回值的类型。*/

-- 结合Lpad函数，如何使主键的值自动加1并在前面补0
-- select LPAD(decode(count(记录编号),0,1,max(to_number(记录编号)+1)),14,'0') 记录编号 from tetdmis
select lpad(decode(count(*),0,1,max(to_number(id) + 1)), 19, '0') id from cpms_customer;
select max(id),lpad(decode(count(*),0,1,max(to_number(id) + 1)), 19, '0') id from cpms_customer;

-- dir 的值是1变为0，是0则变为1
select decode(dir,1,0,1) from a1_interval;


-- 比如我要查询某班男生和女生的数量分别是多少?
-- 通常我们这么写:
-- select count(*) from 表 where sex ＝ 男；
-- select count(*) from 表 where sex ＝ 女；
-- 要想显示到一起还要union一下，太麻烦了
-- 用decode呢，只需要一句话
select decode(sex，'男'，1，0），decode(sex，'女'，1，0） from 表;
-- 统计客户资信度好和一般的客户数量
select sum(decode(a.creditreliability, '01', 1, 0)), sum(decode(a.creditreliability, '02', 1, 0)) from cpms_customer a



-- 3，order by对字符列进行特定的排序
-- 还可以在Order by中使用Decode
-- 可以实现一个字段中的值按照一定的顺序排序，例如：课程排序中按照语文，数学，英语的顺序排列
select * from table_subject order by decode(subject_name, '语文', 1, '数学', 2, , '外语',3)

select * from cpms_customer c order by decode(c.offertype, '05', 1, '03', 2, '04', 3, '01', 4, '02', 5)


-- 4、DECODE实现表的转置
-- 数据库中的表是由列和行构成的一个二维表。一般列在任何数据库中都是有限的数量，而行的变化较大，
-- 如果表很大，行的数量可能大上千万行。同一列的不同行可能有不同的值，而且不是预先定义的。
-- 例:住房公积金报表置换实例：
/*1.各个单位在本地经办行进行开户，开户就是将单位的基本信息和职工信息的进行登记；
2.每月各个单位的会计到经办行交缴本单位的所有职工的住房公积金，系统记录有每个职工的交缴明细并在每条记录上记录有经办行的代码；
3.每月、季、半年及年终都要求将经办行 变为"列"给出个月的明细报表：*/

/*原来的数据顺序是：
城西区2001.01 xxxxx1.xx
城东区2001.01 xxxxx2.xx
城西区2001.02 xxxxx3.xx
城东区2001.02 xxxxx4.xx
经办行：城西区 城东区 
月份：
2001.01 xxxx1.xx xxxxx2.xx 
2001.02 xxxx3.xx xxxxx4.xx 
。 。 。 。 。 。*/
/*住房公积金系统记录职工的每月交缴名细的pay_lst表结构是：
bank_code   varchar2(6)   NOT NULL, -- 经办行代码
acc_no      varchar2(15)  not null, -- 单位代码(单位帐号)
emp_acc_no  varchar2(20)  not null, -- 职工帐号
tran_date   date not      null, -- 交缴日期
tran_val    Number(7,2)   not null, -- 交缴额 
sys_date    date          default  sysdate, --系统日期
oper_id     varchar2(10) --操作员代码
这样的表结构，一般按照将经办行作为行(row)进行统计是很容易的，但是如果希望将经办行变为列(column)这样的格式来输出就有困难。*/

-- 如果用DECODE函数来处理则变得很简单:
-- 我们创建一个视图来对目前的pay_lst表进行查询。将经办行代码变为一些具体的经办行名称即可:
CREATE OR REPLACE VIEW bank_date_lst AS
Select to_char(tran_date,'yyyy.mm'),
SUM( DECODE ( bank_code,'001', tran_val,0 )) 城西区，
SUM( DECODE ( bank_code,'002', tran_val,0 )) 城南区，
SUM( DECODE ( bank_code,'003', tran_val,0 )) 城东区
FROM pay_lst
GROUP BY to_char(tran_date,'yyyy.mm');
-- 建立视图后，可直接对该视图进行查询就可按照列显示出结果。



months_between

lag

over

partition by


group by

having

-- 常用字符串函数
-- 函数  描述
-- LOWER(char) 将字符串表达式char中的所有大写字母转换为小写字母
-- UPPER(char) 将字符串表达式char中的所有小写字母转换为大写字母
-- INITCAP(char) 首字母转换成大写
-- SUBSTR(char, start, length) 返回字符串表达式char中从第start开始的length个字符
-- LENGTH(char)  返回字符串表达式char的长度
-- ASCII(char) 取char的ASCII值
-- CHR(number) 取number的ASCII值
-- REPLACE(char,search_str[,replacement_str])  将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str
-- INSTR(char1,char2[,n[,m]])  获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1
-- LPAD(char1,n,char2) 在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length>n，则返回char1左端的n个字符
-- RPAD(char1,n,char2) 在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length>n，则返回char1左端的n个字符
-- LTRIM(char1[,set])  去掉字符串char1左端包含的set中的任意字符
-- RTRIM(char1[,set])  去掉字符串char1右端包含的set中的任意字符
-- TRIM(char | char From string) 从字符串的头尾或者两端截断特定字符
-- CONCAT(str1,str2) 连接字符串，同||的作用一样
-- LOWER测试
select LOWER('HTTP://WWW.JELLYTHINK.COM') from dual; -- http://www.jellythink.com

-- UPPER测试
select UPPER('http://www.jellythink.com') from dual; -- HTTP://WWW.JELLYTHINK.COM

-- INITCAP测试
select INITCAP('jelly think') from dual; -- Jelly Think

-- SUBSTR测试
select SUBSTR('http://www.jellythink.com', 12, 10) from dual; -- jellythink(注：下标从1开始)

-- LENGTH测试
select LENGTH('JellyThink') from dual; -- 10

-- ASCII测试
select ASCII('A') from dual; -- 65

-- CHR测试
select CHR(65) from dual; -- A

-- REPLACE测试
select REPLACE('jellythink', 'think', ' is good') from dual; -- jelly is good

-- INSTR测试
select INSTR('JellyThink', 'Jelly', 1) from dual; -- 1

-- LPAD测试
select LPAD('JellyThink', 12, '*') from dual; -- **JellyThink

-- RPAD测试
select RPAD('JellyThink', 12, '*') from dual; -- JellyThink**

-- LTRIM测试
select LTRIM('**JellyThink', '*') from dual; -- JellyThink

-- RTRIM测试
select RTRIM('JellyThink**', '*') from dual; -- JellyThink

-- TRIM测试
select TRIM('*' from '**JellyThink**') from dual; -- JellyThink
select TRIM('  JellyThink  ') from dual; -- JellyThink(注：默认去掉空格)

-- CONCAT测试
select CONCAT('Jelly', 'Think') from dual; -- JellyThink


-- 常用日期函数
-- 函数  描述
-- SYSDATE 返回系统当前日期和时间
-- NEXT_DAY(day,char)  返回指定日期day后的第一个工作日char所对应的日期
-- LAST_DAY(day) 返回day日期所指定月份中最后一天所对应的日期
-- ADD_MONTHS(day,n) 返回day日期在n个月后(n为正数)或前(n为负数)的日期
-- MONTHS_BETWEEN(day1,day2) 返回day1日期和day2日期之间相差得月份
-- ROUND(day[,fmt])  返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线，默认舍入到日
-- TRUNC(day,[,fmt]) 日期截断函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日，默认截断到日
-- CURRENT_DATE  返回当前会话时区所对应日期时间
-- EXTRACT 从日期中获取所需要的特定数据
-- SYSDATE测试
select TO_CHAR(SYSDATE,'yyyy-MM-dd hh24:mi:ss') from dual; -- 2015-09-29 15:14:44

-- NEXT_DAY测试
select NEXT_DAY(SYSDATE, '星期一') from dual; -- 2015/10/5 15:16:46

-- LAST_DAY测试
select LAST_DAY(SYSDATE) from dual; -- 2015/9/30 15:17:23

-- ADD_MONTHS测试
select ADD_MONTHS(SYSDATE, 2) from dual; -- 2015/11/29 15:18:39

-- MONTHS_BETWEEN测试
select MONTHS_BETWEEN(SYSDATE, SYSDATE) from dual; -- 0
select MONTHS_BETWEEN(ADD_MONTHS(SYSDATE, -2), ADD_MONTHS(SYSDATE, 2)) from dual; -- -4

-- ROUND测试
select ROUND(SYSDATE) from dual; -- 2015/9/30
select ROUND(SYSDATE, 'YEAR') from dual; -- 2016/1/1
select ROUND(SYSDATE, 'MONTH') from dual; -- 2015/10/1

-- TRUNC测试
select TRUNC(SYSDATE) from dual; -- 2015/9/29
select TRUNC(SYSDATE, 'YEAR') from dual; -- 2015/1/1
select TRUNC(SYSDATE, 'MONTH') from dual; -- 2015/9/1

-- CURRENT_DATE测试
select CURRENT_DATE from dual; -- 2015/9/29 15:22:44

-- EXTRACT测试
select EXTRACT(YEAR from SYSDATE) from dual; -- 2015
select EXTRACT(MONTH from SYSDATE) from dual; -- 9
select EXTRACT(DAY from SYSDATE) from dual; -- 29


-- 常用类型转换函数
-- 函数  描述
-- TO_CHAR 将一个数字或日期转换成字符串
-- TO_NUMBER 将字符型数据转换成数字型数据
-- TO_DATE 将字符型数据转换为日期型数据
-- CAST  将一种built-in类型转换成另一种built-in类型
-- TO_CHAR测试
select TO_CHAR(100) from dual; -- 100
select TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') from dual; -- 2015-09-29 15:36:24

-- TO_NUMBER测试
select TO_NUMBER('10') from dual; -- 10
select TO_NUMBER('JellyThink') from dual; -- 无效数字

-- TO_DATE测试
select TO_DATE('2015-9-29', 'YYYY-MM-DD') from dual; -- 2015/9/29

-- CAST测试
select CAST('100' as NUMBER) from dual; -- 100
select CAST(2 as char) from dual; -- 2


-- 集合函数
-- 函数  描述
-- AVG 计算一列值的平均值
-- COUNT 统计一列中值的个数
-- MAX 求一列值中的最大值
-- MIN 求一列值中的最小值
-- SUM 计算一列值的总和


-- 其它常用函数
-- 函数  描述
-- decode(expression , search , result [, search , result]… [, default]) IF语句的另一形式。将输入数值与参数列表比较，返回对应值。应用于将表的行转换成列以及IF语句无法应用的场合
-- SIGN(number)  如果number大于0，SIGN则返回1；如果number小于0，SIGN则返回-1；如果number等于0，SIGN则返回0
-- TRUNC(number, [ decimal_places ]) number是要截取的数字，decimal_places是要保留的小数位。这个参数必须是个整数。 如果此参数缺省，默认保留0位小数
-- GREATEST(expr1[,expr2]…)  返回表达式中值最大的一个
-- LEAST(expr1[,expr2]…) 返回表达式中值最小的一个
-- NULLIF(expr1,expr2) 如果expr1=expr2；则返回null，否则返回expr1
-- NVL(expr1,expr2)  如果expr1=null；则返回expr2，否则返回expr1
-- NVL2(expr1,expr2,expr3) 如果expr1!=null；则返回expr2；如果expr1=null；则返回expr3
-- DECODE测试
select DECODE(20, 10, 5, 200, 10, 20, 30) from dual; -- 30

-- SIGN测试
select SIGN(20) from dual; -- 1
select SIGN(-30) from dual; -- -1
select SIGN(0) from dual; -- 0

-- TRUNC测试
select TRUNC(20.2183, 2) from dual; -- 20.21
select TRUNC(20.1, 4) from dual; -- 20.1

-- GREATEST测试
select GREATEST(20, 100, 30, 20, 40, 400) from dual; -- 400

-- LEAST测试
select LEAST(20, 100, 30, 20, 40, 400) from dual; -- 20

-- NULLIF测试
select NULLIF(20, 20) from dual; -- NULL
select NULLIF(20, 10) from dual; -- 20

-- NVL测试
select NVL(20, 30) from dual; -- 20
select NVL(NULL, 30) from dual; -- 30

-- NVL2测试
select NVL2(NULL, 20, 30) from dual; -- 30
select NVL2('JellyThink', 20, 30) from dual; -- 20






-- 1.Union可以对字段名不同但数据类型相同的结果集进行合并
-- 2.如果字段名不同的结果集进行Union，那么对此字段的Order by子句将失效
union 
-- 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union all
-- 对两个结果集进行并集操作，包括重复行，不进行排序,可以在最后一个结果集中指定Order by子句改变排序方式


-- lpad和rpad分别是左补位和右补位 
-- repalce(lpad(字段名，共几位)，' '，'0') 
select replace(lpad('123',5),' ','0') from dual 

-- id为19位的补位例子
select to_char(trunc(sysdate), 'yyyymmdd') || replace(lpad(rownum, 11), ' ', '0') as id from dual;

select to_number(to_char(sysdate, 'yyyymmddhh24miss') || replace(lpad(rownum, 5), ' ', '0')) as id from dual;

select count(*) from dual where '' = null; -- count(*)=0
select count(*) from dual where '' is null; -- count(*)=1
select count(*) from dual where '' = ''; --count(*)=0

-- 时间精确到毫秒
select to_char(systimestamp, 'yyyy-mm-dd hh24:mi:ss.ff') from dual;
select to_char(systimestamp, 'yyyy-mm-dd hh24:mi:ss.ff2') from dual;




-- 命名的系统异常     产生原因 
-- access_into_null    未定义对象 
-- case_not_found     case中若未包含相应的when，并且没有设置 
-- collection_is_null    集合元素未初始化 
-- curser_already_open    游标已经打开 
-- dup_val_on_index    唯一索引对应的列上有重复的值 
-- invalid_cursor     在不合法的游标上进行操作 
-- invalid_number    内嵌的 sql 语句不能将字符转换为数字  
-- no_data_found     使用 select into 未返回行，或应用索引表未初始化的  
-- too_many_rows     执行 select into 时，结果集超过一行 
-- zero_divide     除数为 0 
-- subscript_beyond_count    元素下标超过嵌套表或varray的最大值 
-- subscript_outside_limit   使用嵌套表或 varray 时，将下标指定为负数 
-- value_error     赋值时，变量长度不足以容纳实际数据 
-- login_denied     pl/sql 应用程序连接到 oracle 数据库时，提供了不正确的用户名或密码      确的用户名或密码 
-- not_logged_on     pl/sql 应用程序在没有连接 oralce 数据库的情况下访问数据      问数据 
-- program_error     pl/sql 内部问题，可能需要重装数据字典＆ pl./sql系统包     统包 
-- rowtype_mismatch          主游标变量与 pl/sql 游标变量的返回类型不兼容 
-- self_is_null     使用对象类型时，在 null 对象上调用对象方法 
-- storage_error     运行 pl/sql 时，超出内存空间 
-- sys_invalid_id     无效的 rowid 字符串 
-- timeout_on_resource    oracle 在等待资源时超时


--按照sernum分组统计数量
select sernum,count(*) from dsj_xods_bosdb_tillpmnt_crdt_d
group by sernum
having  count(sernum) > 1

--按照sernum分组统计数量，然后查询重复记录
select * from dsj_xods_bosdb_tillpmnt_crdt_d 
where sernum in (
select sernum from dsj_xods_bosdb_tillpmnt_crdt_d
group by sernum
having  count(sernum) > 1
) order by sernum







-- 执行计划的查看
select * from v$sql_plan

-- 执行计划的查看
explain plan for select * from cpms_cardconsumptionday; 
select * from table(dbms_xplan.display)

--查询最近执行过的sql 的执行计划，在sqlplus 在执行 前提是目标sql 还有shared pool 中
select * from table(dbms_xplan.display_cursor(null,null,'advanced'));
select * from table(dbms_xplan.display_cursor(null,null,'all'));

--查指定sql 的执行计划，前提是目标sql 还有shared pool 中，在sqlplus 在执行
select sql_text,sql_id,hash_value from v$SQL where sql_text like '%select * from cpms_cardconsumptionday;%';
select * from table(dbms_xplan.display_cursor('6886uhv5yppd3',0,'advanced'));
select * from table(dbms_xplan.display_cursor('6886uhv5yppd3',0,'all'));

--手动收集 AWR 报告 
call dbms_workload_repository.create_snapshot();

--清空 shared pool  
alter system flush shared_pool;

--select * from scott.emp;  查询已不在 shared pool 中了
select sql_text,sql_id,hash_value,child_number from v$SQL where sql_text like '%select * from cpms_cardconsumptionday;%';

--可以用如下方法查目录SQL 的历史 执行计划，前提是要知道 sql_id 
select * from table(dbms_xplan.display_awr('6886uhv5yppd3'));

--10046 事件, 可以 spool 出来
oradebug setmypid;
oradebug event 10046 trace name context forever,level 12;
select *from scott.dept;
oradebug tracefile_name;  --找到路径及名称 
oradebug event 10046 trace name context off;

--在cmd 命令中 用 tkprof 格式化
tkprof d:\app\administrator\diag\rdbms\orcl\orcl\trace\orcl_ora_9396.trc f:\emp.txt

-- 安装 xplan 包后查看执行计划，可以显示出执行计划的执行顺序，而不是肉眼去观察
-- 1、执行目标
sql select puid,prid,puname,pucred from scott.provuser where puid=100234
-- 2、查询目标sql 的 sql_id,child_number
select sql_text,sql_id,hash_value,child_number from v$SQL where sql_text like '%puid,prid,puname%';
select sql_text,sql_id,hash_value,child_number from v$sql order by last_load_time desc 

--v$sql 中有child_number    v$sqlarea 中无
select sql_text,sql_id,hash_value from v$SQLarea where sql_text like '%puid,prid,puname%';
select sql_text,sql_id,hash_value from v$SQLarea order by last_load_time desc 

--3、查看执行计划
select * from table(xplan.display_cursor('0va10m19a4xaz',0,'advanced'))



select ename,sal from scott.emp a where deptno in (select deptno from scott.dept b where loc='NEW YORK')
select * from v$sql order by last_load_time desc 
select * from table(xplan.display_cursor('gm28940mxxnst',0,'all'))














-- Sql 优化:
/*
当Oracle数据库拿到SQL语句时，其会根据查询优化器分析该语句，并根据分析结果生成查询执行计划。
也就是说，数据库是执行的查询计划，而不是Sql语句。
查询优化器有rule-based-optimizer(基于规则的查询优化器) 和Cost-Based-optimizer(基于成本的查询优化器)。
其中基于规则的查询优化器在10g版本中消失。
对于（RBO）规则查询，其最后查询的是全表扫描。
对于（CBO）规则查询，则会根据统计信息进行最后的选择。

1、先执行From ->Where ->Group By->Order By

2、执行From 字句是从右往左进行执行。因此必须选择记录条数最少的表放在右边。这是为什么呢？

3、对于Where字句其执行顺序是从后向前执行、因此可以过滤最大数量记录的条件必须写在Where子句的末尾，而对于多表之间的连接，则写在之前。
因为这样进行连接时，可以去掉大多不重复的项。

4、SELECT子句中避免使用(*)ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间

5、索引失效的情况:
　① Not Null/Null 如果某列建立索引,当进行Select * from emp where depto is not null/is null。 则会是索引失效。
　② 索引列上不要使用函数,SELECT Col FROM tbl WHERE substr(name, 1, 3) = 'ABC'或者SELECT Col FROM tbl WHERE name LIKE '%ABC%' 
   而SELECT Col FROM tbl WHERE name LIKE 'ABC%' 会使用索引。
　③ 索引列上不能进行计算SELECT Col FROM tbl WHERE col / 10 > 10 则会使索引失效，
   应该改成SELECT Col FROM tbl WHERE col > 10 * 10
　④ 索引列上不要使用NOT （ !=、 <> ）如:SELECT Col FROM tbl WHERE col ! = 10 
   应该改成：SELECT Col FROM tbl WHERE col > 10 OR col < 10 。

6、用UNION替换OR(适用于索引列)
　 union:是将两个查询的结果集进行追加在一起，它不会引起列的变化。 由于是追加操作，需要两个结果集的列数应该是相关的，
并且相应列的数据类型也应该相当的。union 返回两个结果集，同时将两个结果集重复的项进行消除。 如果不进行消除，用UNOIN ALL.

通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 
如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 

在下面的例子中, LOC_ID 和 REGION 上都建有索引.
高效:
　　SELECT LOC_ID , LOC_DESC , REGION
　　FROM LOCATION
　　WHERE LOC_ID = 10
　　UNION
　　SELECT LOC_ID , LOC_DESC , REGION
　　FROM LOCATION
　　WHERE REGION = "MELBOURNE"

低效:
　　SELECT LOC_ID , LOC_DESC , REGION
　　FROM LOCATION
　　WHERE LOC_ID = 10 OR REGION = "MELBOURNE"
如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.

7、用EXISTS替代IN、用NOT EXISTS替代NOT IN
在许多基于基础表的查询中, 为了满足一个条件, 往往需要对另一个表进行联接. 在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 
在子查询中, NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下, NOT IN都是最低效的(因为它对子查询中的表执行了一个全表遍历). 
为了避免使用NOT IN, 我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.

例子：
高效: 
SELECT * FROM EMP (基础表) 
WHERE EMPNO > 0 
AND EXISTS (SELECT 'X' FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = 'MELB')

低效: 
SELECT * FROM EMP (基础表) 
WHERE EMPNO > 0 
AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = 'MELB')
*/